数据结构

## 线性表

线性表的物理存储结构有两种，顺序存储结构与链式存储结构。

### 顺序存储结构

#### 概念

- 线性表List是由零个或多个数据元素组成的有限序列。也就是说可以为空。而当存在多个元素时，第一个元素无前驱，最后一个元素无后继，其他元素都有且只有一个前驱与后继。元素之间是一对一的关系；
- 数据类型是一组性质相同的值的集合及定义在此集合上的一些操作的总称。如C语言中按照取值的不同，数据类型可以分为两类，原子类型（不可分解，如int、double、char）与结构类型（如整型数组）；
- 抽象数据类型 ADT (Abstract Data Type)，类似于面向对象中的类，由方法与属性组成， ADT就是将数据类型与相关操作绑定，与其在计算机内部如何表示与实现无关。如位置坐标xyz；
- 线性表的操作如创建与初始化、判断是否为空、清空、查找、删除、插入等。
- 线性表也称为随机存储结构，因为可以通过一次计算得到线性表中任意位置的地址，存储时间性能为O(1)。
- 线性表相当于在数组上加入一个变量存储当前线性表的长度。线性表位置从1开始计数。数组索引从0开始。
- 线性表在存、读数据时，时间复杂度为O(1)；在插入、删除时，时间复杂度为O(n)。

#### 实现

使用数组实现。线性表相当于在数组上加入一个变量存储当前线性表的长度。

当插入或删除操作的位置在表尾时，后边没有元素，因此不需要移动，此时时间复杂度为O(1)。

如下为插入与删除的完整代码。

~~~c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

/*
Status是函数的类型，返回值是函数结构状态代码，如OK等
初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
操作结果：用e返回L中第i个的数据元素的值
*/ 
Status ListInsert(SqList *L, int i, ElemType e)
{	
	if ( i >= MAXSIZE ) // 线性表已满 
	{
		return ERROR;
	} 
	
	if ( i<1 || i>L->length+1) // 当i不在范围内 
	{
		return ERROR;
	} 
	
	if ( i <= L->length ) // 插入位置不在表尾 
	{
		// 将要插入位置后数据元素向后移动一位 
		int j;
		for ( j=L->length; j>=i; j-- )
		{
			L->data[j] = L->data[j-1];
		}
	}
	
//	插入位置在表尾时，后边没有元素，因此不需要移动 
	L->data[i-1] = e; // 插入元素 
	L->length ++;
	
	return OK;
}

/* 操作结果：删除L的第i个元素，并返回其值 */
Status ListDelete(SqList *L, int i, ElemType *e);
{
	if ( L->length == 0 ) // 空表 
	{
		return ERROR;
	}
	
	if ( i<1 || i>L->length+1 ) // 当i不在范围内
	{
		return ERROR;
	}
	
	*e = L->data[i-1]; // 取出删除元素 
	
	if ( i < L->length ) // 删除位置不在表尾 
	{
		// 将要删除位置后数据元素向前移动一位 
		int j;
		for ( j=i; j<L->length; j++ )
		{
			L->data[j-1] = L->data[j];
		}
	}
	
//	删除位置在表尾时，后边没有元素，因此不需要移动 
	L->length --;
	
	return OK;
}  
~~~

#### 优缺点

- 优点：无需为表示表中元素之间的逻辑关系而增加额外的存储空间，可以快速存取；
- 缺点：插入与删除操作需要移动大量元素。容易造成存储空间的“碎片”。

### 链式存储结构

#### 概念

- 用一组任意的存储单元存储线性表的数据元素，同时存储数据元素信息与后继元素的存储地址（指针）。
- 域指地址，数据域与指针域组成的数据元素称为存储影像，即结点（Node）。头指针是链表的必要条件，不为空。
- 单链表中的第一个结点的存储位置叫做头结点，放在第一个元素结点之前，数据域通常不存储信息，可以用来存放链表的长度。头指针指向头结点，头指针不同于头结点，链表可以没有头结点（空链表），但不可以没有头指针（头指针为空时不存在链表，而空链表是链表）。头结点的存在使得空链表与非空链表处理一致，也方便对链表的开始结点的插入或删除操作。最后一个结点指针为空（NULL）。
- 核心思想是指针后移，即遍历。需要注意None结点没有next属性，单链表只能搜索后继结点不能搜索前驱结点。
- 单链表在插入、删除时，时间复杂度为O(n)，当该操作频繁时效率优势明显。
- 顺序存储结构需要预分配存储空间，单链表不需要考虑存储空间的大小问题。

![img](https://pic2.zhimg.com/80/5a6f7062c70862d5ce5b0ea59d7cb590_hd.jpg)

#### 单链表实现

- 对于要修改链表的内容的操作，需要传入链表的指针，即指向指针的指针，所以必须是*L；
- 新建链表的方法可以分为头插法与尾插法，其中头插法优点是简洁，缺点是逆序，而尾插法顺序；
- 面向对象使用引用机制间接地实现了指针的某些功能。而在C语言之前，使用数组描述的链表叫做静态链表，这种描述方法叫做游标实现法。

~~~c
typedef int ElemType;
typedef int Status;

typedef struct Node 
{
	ElemType data; // 数据域 
	struct Node *next; // 指针域 
} Node; // 结点 

typedef struct Node *LinkList; // 单链表

// 链表内容有变化时函数传入指针，不变时传入数值 
void CreateListHead( LinkList *L, int n );
void CreateListTail( LinkList *L, int n ); 
void PrintList( LinkList L );
Status GetElem( LinkList L, int i, ElemType *e );
Status InsertList( LinkList *L, int i, ElemType e );
Status DeleteList( LinkList *L, int i, ElemType *e );
Status ClearList( LinkList *L );

int main( int argc, char const *argv[] )
{
	LinkList L;
//	PrintList(L); 
	int n = 5;
	
//	CreateListHead(&L, 5); // 5 4 3 2 1
	CreateListTail(&L, 5); // 1 2 3 4 5
	PrintList(L); 
	
	ElemType a;
	
	GetElem(L, 2, &a); // 2
    
    return 0;
}

void CreateListHead( LinkList *L, int n )
{
	int i; // 遍历生成链表
	LinkList p; // 新结点，作为中介 
	LinkList q; // 当前结点 
	
//	因为需要修改链表的内容，需要传入链表的指针，即指向指针的指针，所以必须是*L
//	声明与赋值：*L 对应于函数形参 LinkList *L，p 对应于声明中的 LinkList p; 
	*L = (LinkList)malloc(sizeof(Node)); // 创建带头结点的空单链表
	(*L)->next = NULL; // 头结点数据域不存储信息。头结点未指定data，会随机分配值 
	q = *L; // 指向头结点，不移动 
	
	// 头插法，逆序 
	for ( i=0; i<n; i++ )
	{
		p = (LinkList)malloc(sizeof(Node));
		p->data = i+1;
		
		p->next = q->next;
		q->next = p;
	}
} 

// get指针移动到指定位置，insert与delete指针移动到指定位置的前一位，因此p指针的初始化不同
// 在链表的第i个元素之前插入新的数据元素
Status InsertList( LinkList *L, int i, ElemType e )
{
	LinkList p, q;
	int j;
	
	j = 1;
	p = *L;
	
	// 移动到第i个元素前的那个元素 
	while ( p && j<i )
	{
		p = p->next;
		++ j;
	}	
	
	// 第i个元素不存在 
	if ( !p || j>i ) // 分别满足 j=8、j=0 
	{
		return ERROR;
	}
	
	// 第i个元素存在
	q = (LinkList)malloc(sizeof(Node)); // 生成空结点
	q->data = e;
    
    // 实现插入操作 
	q->next = p->next;
	p->next = q;
	
	return OK;
}

/* 初始条件：顺序线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度-1 */
Status DeleteList( LinkList *L, int i, ElemType *e )
{
	LinkList p, q;
	int j;
	
	j = 1;
	p = *L;
	
	while ( p->next && j<i )
	{
		p = p->next;
	/*
	q = p->next
		p = q;
		q = q->next;
		不满足，如 i=8 
		*/
		++ j;
	}
	
	if ( !(p->next) || j>i )
	{
		return ERROR;
	}
	
	q = p->next;
	p->next = q->next;
	
	*e = q->data;
	free(q);
	
	return OK;
}
~~~

#### 寻找单链表中间结点

设置快慢指针可以用于寻找单链表中间结点，也可以用于单链表中环的检测。

~~~c
Status MidList( LinkList L, ElemType *e )
{
	LinkList p, q;
	
	p = q = L;
	
	while ( p->next != NULL )
	{
		// p的移动速度是q的两倍 
		if ( p->next->next != NULL ) // 偶数 
		{
			q = q->next;
			p = p->next->next;
			printf("%d\t", q->data);
		}
		else // 奇数 
		{
			p = p->next;
			q = q->next;
			printf("%d\t", q->data);
		}
	}
	
	*e = q->data;
	
	printf("\nmid = %d\n", *e);
	
	return OK;
}
~~~

#### 循环链表实现

- 单链表的缺点：不可逆，不从头结点出发，就无法访问到全部结点。
- 单循环链表简称循环链表，将终结点的指针端由空指针改为指向头结点，形成首尾相连的环形单链表。
- 循环链表与单链表的主要差异体现在判断空链表的条件（循环遍历的条件）：rear == rear->next（只有头结点）。
- 单链表操作中间结点时需要遍历以定位，循环链表操作头结点时，需要遍历找出尾结点。
- 以上都是头指针表示的单循环链表，查找尾结点时需要进行遍历，对此做出改进。
- 不用头指针，而是用指向尾结点的尾指针来表示循环链表，这时查找头结点和尾结点的时间复杂度都是O(1)。如用于线性表的拼接。
- 单向循环链表的插入是在尾部插入。
- 循环链表实现初始化时可以有头结点，也可以没有头结点。

~~~c
void InitCListHead( LinkList *L ) // 链表有头结点
{
	int item = 0;
	
	printf("输入结点的值，输入0完成初始化：\n");

	while (1)
	{
        scanf("%d", &item);
        fflush(stdin); // 清空 
        
        if ( item == 0 ) // 退出 
        {
        	return;
        }
        
        /*
		判断初始化的链表有没有结点
		没有结点 先创建头结点 然后插入数据
		有结点 将结点用尾插法插入到链表中
		最后 尾结点的 指针域 指向头结点 这样形成一个环
        */
        if ( !(*L) ) // 空链表 
        {
        	LinkList head = (LinkList)malloc(sizeof(Node)); // 头结点 
        	if ( head == NULL ) // 分配失败 
        	{
        		exit(0); // 错误退出 
        	}
        	
        	*L = head; // 链表指向头结点，头指针指向头结点 。L 存放 head 的地址 
        	
        	LinkList node = (LinkList)malloc(sizeof(Node)); // 第一个结点
        	
        	node->data = item;
        	node->next = head;
        	head->next = node;
        	
//        	(*L)->data = item;
//        	(*L)->next = *L; // 指针域指向它本身
        }
        else // 从第二个结点开始，尾部插入 
        {
        	LinkList cur; // 指向表头
			for ( cur = (*L)->next; cur->next != *L; cur = cur->next ); // 移动指针至表尾
			LinkList head = cur->next; // 头结点 head = *L 
			
			LinkList node;
			node = (LinkList)malloc(sizeof(Node)); // 生成一个新的结点
			
			if ( !(node) ) // 生成失败 
			{
				exit(0);
			}
			
			node->data = item;
			node->next = head;
			cur->next = node;
        }
    } 
}

void InitCListNoHead( LinkList *L ) // 链表没有头结点
{
	printf("输入结点的值，输入0完成初始化：\n");
	
	int item = 0;
	
	while (1)
	{
		scanf("%d", &item);
		fflush(stdin);
		
		if ( item == 0 )
		{
			return;
		}
		
		LinkList node = NULL; // 新增结点，不需要头结点 
		
		if ( !(*L) ) // 空链表 
		{				
			node = (LinkList)malloc(sizeof(Node)); // 添加第一个结点 
			node->data = item;
			
			node->next = node;
			*L = node; // *L就是第一个结点 
		}
		else
		{
			LinkList cur = NULL;
			for ( cur = *L; cur->next != *L; cur = cur->next ); // 移动指针至表尾
			
			node = (LinkList)malloc(sizeof(Node)); 
			node->data = item;
			
			node->next = *L;
			cur->next = node;
		}
	}
}
~~~

#### 约瑟夫问题

分两步，先创建循环链表，再逐一删除结点。

~~~c
typedef struct Node
{
	int data;
	struct Node *next;
} Node;

Node *create( int n );

int main()
{
	int n = 41;
	int m = 3;
	
	Node *p = create(n);
	
	while ( p != p->next )
	{
		int i;
		for ( i=1; i<(m-1); i++ ) // i<m-1 == i<2
		{
			p = p->next;
		}
		
		printf("%d->", p->next->data);
		
		Node *temp; // 中间作用
		temp = p->next;
		p->next = temp->next; 
		free(temp); // 删除结点 
		
		p = p->next;
	}
	printf("%d\n", p->data);
	
	return 0;
}

Node *create( int n )
{
	Node *head = NULL; // 为什么是指针？ 
	head = (Node*)malloc(sizeof(Node)); // 创建头结点，头结点不动，头结点后是第一个结点 
	
	Node *cur= NULL;
	cur = head; // 当前结点，添加结点时会移动 
	
	int i;
	Node *node;
	
	if ( 0 != n )
	{
		for ( i=1; i<=n; i++ ) // 尾插法建立链表
		{
			node = (Node*)malloc(sizeof(Node));
			node->data = i;
			cur->next = node; // 第一个结点
			cur = node;	
		}
		node->next = head->next; // 让最后一个结点指向第一个有数据结点 
	}
	
	free(head); // 构成环后不再需要头结点
	
//	node是最后一个结点，不保留头结点 
	return node->next; // 返回第一个结点
}
~~~

#### 判断单链表中是否有环

- 方法1，比较步数，一个一次走一步，一次每次从头走，位置相同步数不同时判断为有环，两个循环；
- 方法2，快慢指针，一个循环。

~~~c
void InitList( LinkList *L )
{
	// 链表创建头结点 
	Node *head = (Node*)malloc(sizeof(Node));
	head->next = NULL;
	
	if (!head)
	{
		exit(0);
	}
	
	*L = head;
}

void CreateListTail( LinkList *L, int n )
{
	// 创建带头结点的有环链表（尾插法）	
	Node *head = *L;
	Node *cur = head;
	Node *node;
	int i;
	
	for ( i=1; i<=n; i++ )
	{
		node = (Node*)malloc(sizeof(Node));
		node->data = i;
		cur->next = node;
		cur = node;
	}
	node->next = head->next->next->next; // 设置环的位置
}

void CreateListHead( LinkList *L, int n )
{
	// 创建带头结点的无环链表（头插法）
	Node *head = *L;
	head->next = NULL; // 初始化 
	Node *node;
	int i;
	
	for ( i=1; i<=LENGTH; i++ )
	{
		node = (Node*)malloc(sizeof(Node));
		node->data = i;
		node->next = head->next;
		head->next = node;
	}
}

int HasLoop1( LinkList L )
{
	Node *head = L;
	Node *cur1 = head;
	
	int pos1 = 0;
	
	while (cur1) // 结点存在 
	{
		Node *cur2 = head;
		int pos2 = 0;
		
		while (cur2) // cur2 每次从头结点开始移动 
		{
			if ( cur1 == cur2 )
			{
				if ( pos1 == pos2 )
				{
					break; // 没有环 
				} else // 位置相同步数不同时有环 
				{
					printf("环在第%d个结点处\n", pos2);
					return 1;
				}
			}
			cur2 = cur2->next;
			pos2 ++;	
		}
		
		cur1 = cur1->next;
		pos1 ++;
	}
	
	return 0;
}

int HasLoop2( LinkList L )
{
	Node *head = L;
	Node *p = head;
	Node *q = head;
	
	while ( p != NULL && q != NULL && q->next != NULL )
	{
		p = p->next;
		if ( q->next != NULL)
		{
			q = q->next->next;
		}
		
		printf("p: %d, q: %d\n", p->data, q->data);
		
		if ( p == q )
		{
			return 1;
		}
	}
	
	return 0;
}
~~~

#### 魔术师发牌问题

循环链表实现。

~~~c
LinkList CreateLinkList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->next = NULL;
	LinkList L = head;
	Node *cur = head;
	Node *node;
	
	int i;
	
	for ( i=0; i<CardNumber; i++ )
	{
		node = (Node*)malloc(sizeof(Node));
		node->data = 0; // 结点初始化
		
//		if ( head == NULL ) // 设置第一个结点为头结点
//		{
//			head = node;
//		} else 
//		{
//			cur->next = node;
//		}

		cur->next = node;
		cur = node; 
	}
	
	L = head->next;
	node->next = L; // 指向第一个结点 
	
	return L; 
}

void Magician(LinkList *L)
{
	Node *cur = *L;
	cur->data = 1; // 第一个位置
	
	int i;
	int j;
	
	for ( i=2; i<=CardNumber; i++ ) // 从第二个位置开始
	{
		for ( j=1; j<=i; j++ ) // 将cur移动到第i个结点
		{
			cur = cur->next;
			if ( cur->data != 0 )
			{
				j--;
			}
		}
		cur->data = i;
	}
}
~~~

#### 双向循环链表实现

- 结点结构包括前驱结点prior与后继结点next，注意插入与删除操作的顺序；

- 要求支持反向移动，因此需要双向循环链表。前驱结点用于反向移动，后继结点用于正向移动。

~~~c
typedef struct Node
{
	ElemType data;
	struct Node *prior; // 前驱结点 
	struct Node *next; // 后继结点 
} Node, *DualLinkList;

DualLinkList Create()
{
	DualLinkList L;
	Node *head;
	Node *cur; // cur与node都是起中间作用 
	Node *node;
	
	head = (Node*)malloc(sizeof(Node)); // 头结点
	if ( !head ) // 分配失败，返回 NULL 
	{
		exit(0);
	}
	head->prior = NULL; // 初始化 
	head->next = NULL;
	
	L = head;
	cur = head;
	
	int i;
	
	for ( i=0; i<26; i++ ) // 双向链表，没有循环，尾插法实现 
	{
		node = (Node*)malloc(sizeof(Node));
		if ( !node )
		{
			exit(0);
		}
		node->data = 'A' + i; // ASCII A-Z 65-90
		node->prior = cur;
		node->next = cur->next; // 为了程序的通用性 
		
		cur->next = node;
		cur = node;
	}
	
	L = head->next; // 不需要头结点 
	node->next = L; // 循环 
	L->prior = node; 
	
	return L;
}

void Move(DualLinkList *L, int n)
{
	Node *head = *L;
	Node *cur;
	Node *node;
	
	if ( n > 0 ) // 正向，头结点右移 
	{
		int i;
		
		for ( i=0; i<n; i++ )
		{
			head = head->next;
		}		
	} 
	if ( n < 0) // 反向，头结点左移 
	{
		int i;
		n = (-1) * n;
		
		for ( i=0; i<n; i++ )
		{
			head = head->prior;
		}	
	}
	
	*L = head;
}
~~~

## 栈与队列

栈与队列规定了进出的入口，因此相对要比顺序表与链表的实现简单。

### 栈

#### 概念

栈，一个后进先出的线性表。

要求只在表尾进行删除和插入操作。表尾称为栈顶，表头称为栈底。栈顶top存储下一个元素。

栈可用于如浏览器的后退，撤销、函数的实现、编译器检测代码中的括号匹配问题、数值的进制转换等。

基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：

- 向栈中添加元素，此过程被称为"进栈"（入栈或压栈）；

- 从栈中提取出指定元素，此过程被称为"出栈"（或弹栈）。

如图所示：



#### 顺序栈实现

- 栈也分顺序存储结构与链式存储结构，分别简称顺序栈与链栈。首先实现顺序存储结构，使用居多；

- 栈有初始化容量。当栈满时进行扩容，未满时大小不变。因此栈中元素的个数通常不等于栈的最大容量；

- 通常使用数组实现，int top存放的是当前栈顶位于数组的第几号元素，用于索引数组。当栈为空时，top=-1；

- 建议使用int *top，top是指针，存储int的地址，也就是指向int，栈顶用于存储下一个数据。当栈为空时，top=base。此外，建议使用ElemType，具有通用性；
- **push时，先赋值后移动top。pop时，先移动top后赋值**。

~~~c
void InitStack(sqStack *s) // 有大小的空栈 
{
	s->base = (ElemType*)malloc( STACK_INIT_SIZE * sizeof(ElemType) ); // 与普通链表不同，栈有初始化容量
	if ( !(s->base) )
	{
		exit(0);
	} 
	s->top = s->base; // 空栈的栈顶与栈底重合 
	s->stackSize = STACK_INIT_SIZE;
}

void Push(ElemType e, sqStack *s) // 入栈 
{
	if ( s->top - s->base >= s->stackSize ) // 栈满扩容 
	{
		s->base = (ElemType*)realloc(s->base, (s->stackSize + STACK_INCREMETN) * sizeof(ElemType)); // malloc + copy
		if ( !(s->base) )
		{
			exit(0);
		}
		s->top = s->base + s->stackSize; // 设置栈顶 
		s->stackSize += STACK_INCREMETN;
	} 
	
	*(s->top) = e;
	s->top ++; // 移动栈顶 
}

void Pop(ElemType *e, sqStack *s) // 出栈
{	
	if ( s->top == s->base ) // 空栈 
	{
		return;
	}
	s->top --; // 栈顶用于存储下一个数据，因此需要先下移 
	*e = *(s->top);
	printf("%d\n", *e);
}

void TraverseStack(sqStack s)
{
	sqStack *p = &s; // 备份，将地址存入指针 
	
	if ( p->top == p->base )
	{
		printf("栈为空\n");
		return;
	}
	printf("栈内元素包括：\n");
	
	while ( p->top != p->base )
	{
		p->top --;
		printf("%d\t", *(p->top)); // 最后一位也打印了 
	}
	printf("\n");
}

void ClearStack(sqStack *s) // 清空，内存还在 
{
	s->top = s->base; // 移动指针 
}

void DestoryStack(sqStack *s) // 销毁，内存释放 
{
	int i;
	int len;
	len = s->stackSize;
	
	for ( i=0; i<len; i++ )
	{
		free(s->base);
		s->base ++;
	}
	
	s->base = s->top = NULL;
	s->stackSize = 0;
}

int LenStack(sqStack s) // 返回栈中元素的个数，通常不等于栈的最大容量 
{
//	return (s->top - s->base); // 错误，s是结构体，不是指针 
	return (s.top - s.base);
}
~~~

#### 进制转换

- 二进制转换为十进制。如二进制1011转换成十进制是11，采用按权展开求和的方法，具体如下：

  ![img](https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=1986c47e5482b2b7a7ca31c2019de7d7/622762d0f703918f182e61b05c3d269758eec4c9.jpg)

- 二进制转换为八进制、十六进制。使用两个栈。

~~~c
int main()
{
	Stack s; // 存储二级制的栈 
	InitStack(&s); // 初始化 
	
	printf("请输入8位二进制数：\n");
	
	int i;
	ElemType e;	
	
	for ( i=0; i<STACK_INIT_SIZE; i++ ) // 生成二进制数 
	{
		scanf("%d", &e);
		Push(&s, e); // 进栈 
	}
	
	int j; 
	Stack t; // 存储8进制的栈
	InitStack(&t); 
	
	int len = LenStack(s); // LenStack(s)的返回值在变化 
	
	for ( i=0; i<len; i+=3 )
	{
		int n = 0;
		int num = 0; // 3位二进制转换成的十进制 
		
		for ( j=0; j<3; j++ )
		{
			if ( s.top == s.base ) // 到栈底了 
			{
				break;
			}
			Pop(&s, &n); // 出栈 
			num += n * pow(2, j);
		}
		
//		printf("n = %d\n", num);
		Push(&t, num); // 入栈 
	}
	
//	打印存储八进制的栈 
	while ( t.top != t.base )
	{
		t.top --;
		printf("%d\t", *(t.top));
	}
	printf("\n");
	
	return 0;
} 
~~~

#### 链栈实现

- 实现单链表实现。

- 因为只是栈顶来做插入和删除操作，所以比较好的方法就是将栈顶放在单链表的头部，栈顶指针和单链表的头指针合二为一。

~~~c
typedef struct Node // 结点 
{
	ElemType data;
	struct Node *next;
} Node;

typedef struct // 链栈 
{
	Node *top; // 栈顶指向头结点 
	int count; // 栈元素计数器 
} LinkStack;

int main()
{
	LinkStack s;
	int i;
	
	if ( InitStack(&s) ) // 初始化 
	{
		printf("Stack is empty: %d\n", StackEmpty(s)); // 栈为空 
		for ( i=0; i<10; i++ )
		{
			Push(&s, i + 1); // 入栈 
		}
		printf("Stack is empty: %d\n", StackEmpty(s)); // 栈不为空 
	}
	
	PrintStack(s);
	
	Pop(&s, &i); // 出栈
	PrintStack(s); // 可以执行多次 
		
	return 0;
}

Status InitStack(LinkStack *s)
{
//	LinkStack s = (LinkStack*)malloc(sizeof(LinkStack));
	s->top = (Node*)malloc(sizeof(Node));
	if ( !(s->top) )
	{
		return ERROR;
	}
	s->top = NULL;
	s->count = 0;
	return OK;
}

Status Push( LinkStack *s, ElemType e ) // 入栈 
{
	Node *p = (Node*)malloc(sizeof(Node)); // p 存储 Node 的地址 
	p->data = e;
	p->next = s->top; // 头插法，新结点指向现有的第一个结点。top不动 
	s->top = p;
	s->count ++;
}

Status Pop( LinkStack *s, ElemType *e )
{
	if ( StackEmpty(*s) )
	{
		return ERROR;
	}
	
	Node *p;
	p = s->top;
	*e = p->data;
	printf("元素 %d 出栈\n", *e);
	
	s->top = p->next;
	free(p);
	s->count --;
	
	return OK;
}
~~~

#### 逆波兰计算器

核心是去掉括号。借助顺序栈记忆符号的优先级。

- 运算的优先级规则为从左向右，括号优先级最高，先乘除后加减；
- 逆波兰表达式 RPN，不需要括号的后缀表达式，也就是将操作符放在数字的后面；
- **中缀表达式转换为后缀表达式**。从左向右遍历每个元素，是数字直接输出，是符号判断优先级；
- 逆波兰计算器的实现分两步，先将中缀表达式转换为后缀表达式，再根据逆波兰表达式计算结果。

~~~c
/*使用顺序栈实现逆波兰表达式*/
#define STACK_INIT_SIZE 10
#define STACK_INCREMENT 20
#define MAXBUFFER 		10

typedef double ElemType;

typedef struct
{
	ElemType *top;
	ElemType *base;
	int size;
} Stack;

void InitStack(Stack *s);
void PushStack(Stack *s, ElemType e);
void PopStack(Stack *s, ElemType *e);
void PrintStack(Stack s);

int main()
{
	Stack s;
	InitStack(&s); // init 

	printf("请按逆波兰表达式输入待计算数据，数据与运算符之间用空格隔开，以#作为结束标志: \n");

	char c;
	scanf("%c", &c);
	
	char str[MAXBUFFER]; // 缓冲区数组，将没有空格的数字合并 123 4
	int i = 0;	// 数组索引 
	double a, b; // 支持小数计算 
	
	while ( c != '#' )
	{
		while ( isdigit(c) || c == '.' ) // 用于过滤数字 123 4 + 5
		{
			str[i++] = c;
//			printf("c = %c\n", c);
			str[i] = '\0'; // 字符串结尾
			
			if ( i >= 10 )
			{
				printf("出错：输入的单个数据过大！\n");
				return -1; // main
			}
			
			scanf("%c", &c);
			
			if ( c == ' ' ) // 输入的数字之间以空格分隔，数字输入结束 
			{
				a = atof(str); // 将字符串转换为浮点数
//				printf("%f\n", a);
				PushStack(&s, a); // 一个数字入栈 123
				i = 0; // 缓冲区数组重置 
				break;
			} 
		}
		
		switch (c) // 操作符，没有入栈 
		{
			case '+':
				PopStack(&s, &a); // 使用指针返回值 
				PopStack(&s, &b);
				PushStack(&s, b+a);
				break;
			case '-':
				PopStack(&s, &a);
				PopStack(&s, &b);
				PushStack(&s, b-a); // a先出栈 
				break;
			case '*':
				PopStack(&s, &a);
				PopStack(&s, &b);
				PushStack(&s, b*a);
				break;
			case '/':
				PopStack(&s, &a);
				PopStack(&s, &b);
				if ( a == 0 )
				{
					return -1;
				} else
				{
					PushStack(&s, b/a);
				}
				break;
		}		
		
		scanf("%c", &c);
	}
	
	PrintStack(s); // 栈内一个元素
	
	PopStack(&s, &a);
	printf("最终的计算结果为：%f\n", a); 
	
//	8 - (8 + 8) + 8 + 9 / 4 --> 8 8 8 + - 8 + 9 4 / + # 2.25
	
	return 0;
}

//  中缀表达式转换为后缀表达式
int main()
{
	Stack t; // 存放运算符，不含括号，数字直接打印
	Init(&t); 
	
	printf("请输入要计算的中缀表达式，中间不需要空格分隔，使用英文运算符，输入以#结尾：\n");	
	
	char c;
	scanf("%c", &c);
	
	char d; // 从t中出栈 
	
	/*总结规则：从左到右遍历中缀表达式的每个数字和符号，若是数字则直接输出，若是符号，则判断其与栈顶符号的优先级，
					是右括号或者优先级低于栈顶符号，则栈顶元素依次出栈并输出，直到遇到左括号或栈空才将吃屎的那个符号入栈。		
	*/
	while ( c != '#' )
	{
		while ( c >= '0' && c <= '9' ) // 输入的是数字（连续输入，不止一位的数字） 
		{
			printf("%c", c);
			scanf("%c", &c);
			if ( c < '0' || c > '9' ) // 数字输入结束 
			{ 
				printf(" ");
			}
		}
		
		// 输入的是符号
		if ( ')' == c ) // 符号中括号的优先级最高，优先出栈 
		{
			Pop(&t, &d); // 栈不为空
			// 不是(时打印。左括号只弹出并不输出。只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。
			while ( '(' != d )  
			{
				printf("%c ", d);
				Pop(&t, &d);
			}
		} 
		
		else if ( '-' == c || '+' == c ) // 乘除优先级高于加减，先出栈 
		{
			if ( !(Len(t)) ) // 空栈，符号直接入栈 
			{
				Push(&t, c);
			} 
			else // 非空栈，部分元素可能需要出栈 
			{
				do
				{
					Pop(&t, &d);
					if ( '(' == d ) // 加减在括号内部 
					{
						Push(&t, d);
					}
					else // +-*/
					{
						printf("%c ", d);
					} 
				} while ( Len(t) && '(' != d ); // 循环至少执行一次
				
//				do-while == while + 1 
				
				Push(&t, c); // 判断后入栈 
			}
		}
		
		else if ( '*' == c || '/' == c || '(' == c)
		{
			Push(&t, c);
		}
		
		else if ( '#' == c ) // 再过滤一次，否则 # 报错 
		{
			break;
		}
		
		else // 要求输入英文括号 
		{
            printf("\n出错：输入格式错误！\n");
            return -1;
		}
		
		scanf("%c", &c);
	}

	while ( Len(t) )
	{
		Pop(&t, &d);
		printf("%c ", d);
	}
    
	return 0;
}
~~~

### 队列

#### 概念

- 与栈不同，队列Queue是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。如输入缓冲区的实现；
- 栈常用顺序表实现，队列常用链表实现。约定队尾插入，队头删除。

#### 链式队列实现

~~~c
void InitQueue( LinkQueue *q )
{
	q->front = q->rear = (Node*)malloc(sizeof(Node));
	if ( !(q->front) )
	{
		exit(0);
	}
	q->front->next = NULL; // rear的next可以不指定 
}

void InsertQueue( LinkQueue *q, ElemType e ) // 尾插法 
{
	Node *p = (Node*)malloc(sizeof(Node));
	if ( !p )
	{
		exit(0);
	}
	p->data = e;
	p->next = NULL; 
	q->rear->next = p;
	q->rear = p;
}

void DeleteQueue( LinkQueue *q, ElemType *e ) // 头删法 
{
	if ( q->front == q->rear ) // 空队列 
	{
		exit(0);
	} 
	Node *p = q->front->next; // q->front不存储数据
	*e = p->data;
	q->front->next = p->next;
	
	if ( q->rear == p ) // 队列只有一个元素。删除以后只剩下头结点 
	{
//		q->rear->next = NULL;
		q->rear = q->front;
	}
	
	free(p);
}
~~~

#### 循环队列实现

- 顺序存储的队列（数组）队尾插入的时间复杂度为O(1)，而队头删除的时间复杂度为O(n)。因为队头不动；

- 当队头可移动时，会出现假溢出的风险，即队尾到了数组尾部，同时造成内存浪费。如下图所示，因此提出循环队列；![1569479382886](C:\Users\HMZ\AppData\Roaming\Typora\typora-user-images\1569479382886.png)

- 循环队列的容量是固定的，并且它的队头和队尾指针都可以随着元素入出队列而发生改变，这样循环队列逻辑上就好像是一个环形存储空间。队尾指向可入列的位置；

- 让front或rear指针不断加1，即时超出了地址范围，也会自动从头开始。我们可以采取取模运算处理。取模运算的值永远不会大于除数；

- 根据重合无法区分队列为空或是满，因此队列数组的最后一个存储空间不用。如图所示，假设数组的存数空间为7，此时已经存放1，a，5,7,22,90六个元素了，如果在往数组中添加一个元素，则rear=front；此时，队列满与队列空的判断条件front=rear相同，这样的话我们就不能判断队列到底是空还是满了。

  解决这个问题有两个办法：一是增加一个参数，用来记录数组中当前元素的个数；第二个办法是，少用一个存储空间，也就是数组的最后一个存数空间不用，当（rear+1）% maxsize=front时，队列满；

- 所有和事件有关的操作都有队列的影子。如可用于缓冲数据。比如，某一时间cpu太忙，收到的数据来不及处理了，这时候就可以把数据先存到循环队列，等cpu不忙了再拿出来处理。

![img](https://img-blog.csdn.net/20140307190145546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHBwMDkwMDMyMDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

~~~c
typedef struct
{
	ElemType *base; // 动态分配内存基地址 
	int front; // 索引
	int rear; 
} LoopQueue;

void Init( LoopQueue *q )
{
	q->base = (ElemType*)malloc( MAXSIZE * sizeof(ElemType) ); // 动态分配内存基地址 
	if ( !(q->base) )
	{
		exit(0);
	}
	q->front = 0; // 取值范围 0 -- size-1 
	q->rear = 0;
}

void Insert( LoopQueue *q, ElemType e ) // 尾插法 
{
//	根据重合无法区分队列为空或是满，因此队列数组的最后一个存储空间不用
	if ( (q->rear+1) % MAXSIZE == q->front ) // 队列满，重合 
	{
		printf("队列已满\n");
//		exit(0); // 进程退出 
		return;  // 函数退出 
	}
	q->base[q->rear] = e;
	q->rear = (q->rear+1) % MAXSIZE; // 移动到下一位。队尾指向可入列的位置 
}

void Delete( LoopQueue *q, ElemType *e )
{
	if ( q->rear == q->front ) // 队列空，重合。不存在 (q->rear)%MAXSIZE == q->front 
	{
		printf("队列为空\n");
		return;
	}
	*e = q->base[q->front];
	printf("删除元素%d\n", *e);
	q->front = (q->front+1) % MAXSIZE;
}

void Traverse( LoopQueue q )
{
	// 不满足 rear < front 
//	int i;
//	for ( i = q.front; i < q.rear; i++ ) 
//	{
//		printf("%d\t", q.base[i]);
//	}
//	printf("\n");

	LoopQueue *p = &q;
	printf("队列内元素依次为：\n");
	while ( p->rear != p->front ) // 通过删除结点实现 
	{
		printf("%d\t", p->base[p->front]);
		p->front = (p->front+1) % MAXSIZE;
//		p->front = p->front + 1; // 死循环 
	}
	printf("\n");
}
~~~

### 递归与分治

- 尽量使用迭代而不是递归。递归内存消耗较大，原因是函数调用时需要入栈出栈，CPU寄存器需要对其进行保存与恢复；
- 将调用自身的函数称作递归函数。递归建立函数副本，消耗时间与内存。递归函数分为调用与回退阶段，顺序相反。

#### 斐波那契数列

- 递归：涉及了大量的重复运算；
- 递归优化：存储重复数据，在时间复杂度上优化，但是需要引入额外的数组，增加了空间复杂度；
- 迭代：使用循环，不仅降低了时间复杂度，并且空间复杂度为常数；
- 调用 time 头文件用于打印程序运行消耗的时间。

~~~c
int main()
{
	int N = 45; // 从0开始，第 N+1 个元素 
	
	// 递归消耗的时间
    clock_t recursion_start_time = clock();
    long result_recursion = Fib_recursion_1(N);
    clock_t recursion_end_time = clock();
	
	// 输出递归消耗的时间
    printf("Result of recursion: %ld \nTime: %f seconds", result_recursion,
        (double)(recursion_end_time-recursion_start_time) / CLOCKS_PER_SEC
    );
    printf("\n-----------------------\n");
    
    int arr[N+1];
    int i;
    for ( i = 0; i <= N; i++ ) // 数组初始化
    {
    	arr[i] = 0;
    }
    
    // 递归优化后消耗的时间
    recursion_start_time = clock();    
    // ERROR variable-sized object may not be initialized
    // 在C中，使用变量来定义数组长度时，这个数组可以定义，却不能同时进行初始化赋值，需要在之后赋值。
    result_recursion = Fib_recursion_2(N, arr);
    recursion_end_time = clock();
    
	// 输出递归优化后消耗的时间
    printf("Result of recursion: %ld \nTime: %f seconds", result_recursion,
        (double)(recursion_end_time-recursion_start_time) / CLOCKS_PER_SEC
    );
    printf("\n-----------------------\n");
    
    // 迭代消耗的时间
    clock_t iteration_start_time = clock();
    long result_iteration = Fib_iteration(N);
    clock_t iteration_end_time = clock();
    
    // 输出迭代消耗的时间
    printf("Result of iteration: %ld \nTime: %f seconds", result_iteration,
        (double)(iteration_end_time-iteration_start_time) / CLOCKS_PER_SEC
    );
	
	return 0;
}

int Fib_recursion_1(int N)
{
	if ( N < 2 )
//		return N == 0 ? 0 : 1;
		return N;
	return Fib_recursion_1(N-1) + Fib_recursion_1(N-2);
}

int Fib_recursion_2(int N, int arr[])
{
	if ( arr[N] == 0 )
	{
		if ( N < 2 )
		{
			arr[N] = N;
		}
		else{
			arr[N] = Fib_recursion_2(N-1, arr) + Fib_recursion_2(N-2, arr);
		}
	}
	
	return arr[N];
}

int Fib_iteration(int N)
{
	if ( N < 2 )
	{
		return N;
	}
	
	long m = 0;
	long n = 1;
	long temp;
	int i;
	for ( i=2; i<=N; i++ )
	{
		temp = m;
		m = n;
		n = temp + n;
	}
	
	return n;
}
~~~

#### 字符串逆序

先使用递归实现，再使用栈实现。

~~~c
int main()
{
	char c;
	printf("请选择实现方式，输入1表示使用递归实现，输入2表示使用栈实现：\n");
	scanf("%c", &c);
    
	switch (c)
	{
		case '1':
			printf("请输入字符串，以#结尾：\n");
			
			Print();
			
			break;
		case '2':
			printf("请输入字符串，以#结尾：\n");
			
			Stack s;
			InitStack(&s);
			ReverseStack(&s);
			
			break;
	}
    
	return 0;
}

void Print()
{
	char c;
	scanf("%c", &c);
	
	if ( c != '#')
	{
		Print(); // 递归 
	}
	
	if ( c != '#' ) // 逆序输出
	{
		printf("%c", c);
	} 
}

void ReverseStack(Stack *s)
{
	char c;
	
	scanf("%c", &c);
	while ( c != '#' )
	{
		PushStack(s, c);
		scanf("%c", &c);
	} 
	
	do
	{
		PopStack(s, &c);
		printf("%c", c);
	} while ( s->size != 0);
	printf("\n");
} 
~~~

#### 汉诺塔问题

分治思想，各个小模块通常具有与大问题相同的结构，这种特性也使递归技术有了用武之地。

实现汉诺塔算法可以简单分为三个步骤：

- 把n-1个盘子由A 移到 B；

- 把第n个盘子由 A移到 C；

- 把n-1个盘子由B 移到 C。

如图所示是当 n=3 时的移动步骤：

![img](https://pic1.zhimg.com/50/v2-64e912ac46acca5b5114052d2e7aaf2e_hd.gif)

而当 n=4 时，也就是移完发现左边柱子下面又蹦出来一个盘子的情况下，可以把中间的柱子看成目标柱，然后把最大的移到右边, 然后就和搬三个一模一样了。

![img](https://pic2.zhimg.com/50/v2-77f7888545bc94292253725fd5033bad_hd.webp)

~~~c
// 将 n 个盘子从 x 借助 y 移动到 z
void move( int n, char x, char y, char z )
{
	if ( 1 == n )
	{
		printf("%c-->%c\n", x, z);
	}
	else
	{
		move( n-1, x, z, y ); 			// 将 n-1 个盘子从 x 借助 z 移到 y 上
		printf("%c-->%c\n", x, z); 		// 将 第 n 个盘子从 x 移到 z 上
		move( n-1, y, x, z ); 			// 将 n-1 个盘子从 y 借助 x 移到 z 上
	}
}
~~~

#### 八皇后问题

回溯算法的典型例题，先用递归算法求解。

深度优先。

本算法的思路是按行来规定皇后位置，第一行放置一个皇后，第二行放置一个皇后， 第N行也放置一个皇后… 这样， 可以保证每行都有一个皇后，那么各行的皇后应该放置在那一列呢， 算法通过循环来完成，在循环的过程中， 一旦找到一个合适的列，则该行的皇后位置确定，则继续进行下一行的皇后的位置的确定。由于每一行确定皇后位置的方式相似，所以可以使用递归法。一旦最后一行的皇后位置确定，则可以得到一组解。

找到一组解之后， 之前确定皇后应该放置在哪一列的循环其实才进行了一轮循环的， 算法通过该循环遍历所有的列，以此确定每一行所有可能的列的位置。在从一轮循环进入下一轮循环之前，算法需要清除在上一轮被标记为不可放置皇后的标记，也就是回溯。因为进入下一轮循环之后，同一行的皇后的列的位置会发生了变化，之前被标记为不可放置皇后的列和正反对角线位置都已经失效。 

~~~c
int count = 0;

int notDanger( int row, int j, int (*chess)[8] ) // 危险：同行同列、对角线 
{
	// 同行、下方（左下方、右下方）天然成立，不需要检查 
	// 同列 
	int i;
	for ( i=0; i<row; i++ ) // i为行，检查当前行之前的行 
	{
//		if ( *(*(chess+i)+j) != 0 )
		if ( chess[i][j] != 0 )
		{
			return 0;
		}
	} 
	
	int k;
	for ( i=row, k=j; i>=0 && k>=0; i--, k-- ) // 左上方 
	{
//		if ( *(*(chess+i)+k) != 0 )
		if ( chess[i][k] != 0 )
		{
			return 0;
		}
	}
	
	for ( i=row, k=j; i>=0 && k<8; i--, k++ ) // 右上方 
	{
//		if ( *(*(chess+i)+k) != 0 )
		if ( chess[i][k] != 0 )
		{
			return 0;
		}
	}
	
	return 1; // 没有危险 
}

// row当前行
// col所有列 
// 参数(*chess)[8]: 表示指向棋盘每一行的指针。行为指针，列为数组
void EightQueen( int row, int col, int (*chess)[8] )
{
	int temp[8][8];
	int i, j;
	for ( i=0; i<8; i++ )
	{
		for ( j=0; j<8; j++ )
		{
			temp[i][j] = chess[i][j]; // 初始化 
		}
	}
	
	if ( 8 == row ) // row 0-7 一种方法结束，递归的结束条件
	{
		printf("第 %d 种具体方案如下：\n", count+1); // count从0开始 
		for ( i=0; i<8; i++ ) // 行 
		{
			for ( j=0; j<8; j++ ) // 列 
			{
				printf("%d ", temp[i][j]); // wrong!?
//				printf("%d ", *(*(temp+i)+j));
			}
			printf("\n");
		}
		printf("\n");
		count ++;
	}
	else // 开始递归 
	{
		for ( j=0; j<col; j++ ) // 当前行的所有列 
		{
			 // 判断是否危险 row行j列 判断该行中的所有列是否危险 (危险返回 0, 安全返回 1) 
			if ( notDanger(row, j, chess) ) // 没有危险。第一次是chess，之后是temp 
			{
				for ( i=0; i<8; i++ )
				{
//					*(*(temp+row)+i) = 0; 
					temp[row][i] = 0;
				}
//				*(*(temp+row)+j) = 1; // 放置皇后
				temp[row][j] = 1; 
				EightQueen( row+1, col, temp ); // 下一行，因为一行一定只有一个安全的位置 
			}
		}
	}
}

int main()
{
	int chess[8][8];
	int i, j;
	
	for ( i=0; i<8; i++ )
	{
		for ( j=0; j<8; j++ )
		{
			chess[i][j] = 0; // 初始化 
		}
	}
	
	EightQueen( 0, 8, chess );
	
	printf("解决方法共 %d 种\n", count); 
	
	return 0;
}
~~~

### 字符串

#### 概念

刚开始的计算机都是处理数值工作，后来引入了字符串的概念，计算机开始可以处理非数值的概念了（当然原理还是用数值来模拟非数值，通过ASCII码表）。

标准 ASCII 码使用 7 个二进位对字符进行编码。基本的 ASCII字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。虽然标准 ASCII 码是 7 位编码，但由于计算机基本处理单位为字节（1byte = 8bit），所以一般仍以一个字节来存放一个 ASCII 字符。每一个字节中多余出来的一位（最高位）在计算机内部通常保持为 0（在数据传输时可用作奇偶校验位）。

常见字符的ASCII码值如下：

- 空格的ASCII码值为32；
- 数字0到9的ASCII码值为48到57；
- 大写字母“A”到“Z”的ASCII码值为65到90；
- 小写字母“a”到“z”的ASCII码值为97到122。即小写字母大于大写字母；

记住很重要的一点，单引号是字符型，双引号是字符串型。

字符串比较大小时比的就是字符串里每个字符的ASCII码大小。主要是通过模式匹配判断是否相等。

通常使用顺序存储结构进行存储。

#### BF算法

属于朴素的模式匹配算法，效率较低。

BF算法在进行模式匹配时，从主串的第一个字符开始，每次失败，模式串向后移动一个字符的位置，继续匹配**（回溯法）**。但是整个算法受测试数据的影响非常大，在解决实际问题时，由于数据量庞大，时间复杂度往往会很高。

具体示例如图所示：

![img](http://data.biancheng.net/uploads/allimg/170719/2-1FG9133440945.png)

时间复杂度：

- “BF” 算法在最理想的情况下的时间复杂度为O(m)( m 是模式串的长度，也就是第一次匹配就成功的情况)。

- 一般情况下，"BF"算法的时间复杂度为O(n+m)(n是主串的长度，m是模式串的长度)。

- 最坏的情况下的时间复杂度为O(n * m)（例如主串 S 为“000000000001”，模式串 T ”001”,每次匹配时，直到匹配最后一个元素，才得知匹配失败，运行了 n*m 次）。

~~~c
// 返回子串T在主串S中第pos个字符之后的位置
int stringIndex( char S[], char T[], int pos )
{
	int i = pos; // 主串下标
	int j = 0; // 子串下标，取值从0开始，要从1开始需要手动在结构体中设置（字符串使用了第一个元素表示长度的方式，省去末尾的\n） 
	
	int m = strlen(S);
	int n = strlen(T);
	
	while ( i < m && j < n ) // i或j其中一个到达尾部即终止搜索
	{
		if ( S[i] == T[j] ) // 若相等则继续下一个元素匹配
		{
			printf("S[%d] = %c, T[%d] = %c\n", i, S[i], j, T[j]);
			i ++;
			j ++;
		}
		else
		{
//			i ++; // wrong
			i = i - j + 1; // i回溯到上次匹配首位的下一个元素，这是效率低下的关键！如当 i=1, j=0 时更新 i=1-0+1=2
			j = 0; // 若失配则j回溯到第一个元素重新匹配
		}
	} 
	
	// 跳出循环有两种可能，i=strlen(S)说明已经遍历完主串；j=strlen(T),说明模式串遍历完成，在主串中成功匹配
	if ( j == n ) // j=strlen(T)
	{
		return i - n;
	}
	else // i=strlen(S)
	{
		return 0; // 若不存在，则返回0
	}
}

int main()
{
	char S[] = "IFFamFishc";
	char T[] = "Fish";
	
	int pos = 0;
	
	int n = stringIndex(S, T, pos);
	
	printf("T子串在S主串中的起始匹配位置为：%d\n", n);
	
	return 0;
}
~~~

#### KMP算法

**主串索引不动或者向前移动，不会往回倒着走。**

- 核心是避免重复遍历，即避免不必要的回溯；
- 对子串进行自检，决定回溯的多少。回溯即向左移动。子串（模式串）元素不同时，回溯较少，元素相同（即有重复）时，回溯较多；
- 问题由模式串决定，不是由目标决定。模式匹配串称为T串，不需要考虑被匹配串S串（主串）；
- 给模式匹配串添加一个k数组（也就是KMP算法中著名的next数组）。k数组指导着模式匹配串下一步改用第几号元素去进行匹配；
- 关注T串前缀后缀重叠的个数，其中前缀后缀是针对失配位置而言的。第一个元素永远是前缀，失配元素的前一个永远是后缀。前缀与后缀是可以相同的；
- 查找字串在主串中的位置。下标等同于后缀，next等同于前缀。
- 回溯：T[6] != T[4]在4处失配。对于4来说，6就是S串，0-4相当于T串。然后根据4处的next值开始递归，回溯到上一个失配串。

[以图中的例子来说](https://www.zhihu.com/question/21923021)，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。

![img](https://pic4.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg)

**next数组中值的意义是字符串的前缀集合与后缀集合的交集中最长元素的长度**。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。

![img](https://pic2.zhimg.com/80/v2-f2b50c15e7744a7b358154610204cc62_hd.jpg)

关于为什么要把pmt向左移动1位变成next，我觉得这样比较好理解 -> pmt记录的是 长字符串的后缀（和短字符串的前缀） 的长度，具体到前缀部分的index的时候要-1。

next数组的计算，我理解是p串错开一位匹配，0起始的p串与1起始的p串，前者是瞄准了p的前缀，后者抛弃了p[0]所以是瞄准p的后缀，双方的公共部分即是公共前后缀。

~~~c
void get_next( char T[], int *next )
{
	// 前缀固定，后缀相对
	int j = -1; // 前缀 
	int i = 0; // 后缀
	int n = strlen(T);
	
	next[0] = -1;
	
	while ( i < n ) // T[3] == T[1]
	{
		if ( -1 == j || T[i] == T[j] )
		{
			i ++;
			j ++;
			next[i] = j; // next[4] = 2
		}
		else
		{
			j = next[j]; // 回溯 2 = next[4]
		}
	} 
	
	for ( i=0; i<n; i++ ) // 打印 
	{
		printf("%d\t", next[i]);
	}
	printf("\n");
}

int index_kmp( char S[], char T[], int pos )
{
	int i = pos; // 主串
	int j = 0; // 字串
	
	int next[255]; // next数组 
	get_next( T, next ); // 只执行一次 
	
	int m = strlen(S);
	int n = strlen(T);
	
	while ( i < m && j < n )
	{
		if ( -1 == j || S[i] == T[j] )
		{
			i ++;
			j ++;
		}
		else
		{
			j = next[j]; // KMP与BF不同之处 
		}
	}	
	
	if ( n == j ) // 找到 
	{
		return i - n;
	}
	else // 没找到 
	{
		return -1;
	}
}
~~~

具体的一个例子如图所示：

![1571489634553](C:\Users\HMZ\AppData\Roaming\Typora\typora-user-images\1571489634553.png)

## 树与图
### 树

#### 概念

- 树：树可以为空。除了根结点外，每个子结点可以分为多个不相交的子树。有根结点的树就有子树，子树有顺序。
- 度：树的度是树的结点的度的最大值，每个结点都有度，度为0的结点为根结点；
- 层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。树中结点的最大层次称为树的高度；
- 叶子结点：一棵树当中没有子结点（即度为0）的结点称为叶子结点，简称“叶子”。 叶子是度为0的结点，又称为终端结点。

#### 树的存储结构

树中的某个结点的孩子可以有多个，所以仅仅使用简单的顺序结构或者链式结构是不能完全表示一整棵树的。充分利用顺序存储结构和链式存储结构的特点，完全可以实现对树的存储结构的表示。

表示一棵树的方法如：双亲表示法，孩子表示法，孩子兄弟表示法。

- 对于双亲表示法：我们先将双亲结点存入，我们每插入一个结点都是知道双亲结点位置的，数据可以直接插入。使用顺序存储结构更加方便；
- 而对于孩子表示法，我们每次插入一个结点，对其子树的位置存放暂不确定，所有使用链式存储结构占主要。

对孩子表示法优化后的双亲孩子表示法查询双亲与孩子的时间复杂度都是O(1)，**结合顺序结构与链式结构**，结构如下图所示。之后是结构体定义代码。

![img](https://images2018.cnblogs.com/blog/1309518/201808/1309518-20180811153742040-189033066.png)

~~~c
typedef char ElemType;

// 孩子结点 
typedef struct CTNode
{
	int child;				// 孩子结点的下标
	struct CTNode *next;	// 指向下一个孩子结点的指针	
} *ChildPtr;

// 表中的每一行（表头结构）
typedef struct
{
	ElemType data;			// 存放在树的结点中的数据
	int parent;				// 存放双亲的下标
	ChildPtr firstchild;	// 指向第一个孩子的指针 
} CTBox;

// 树结构 
typedef struct 
{
	CTBox nodes[MAX_TREE_SIZE];	// 结点数组
	int r;						// 根的位置 
	int n; 						// 结点个数 
} Tree;
~~~

#### 二叉树的种类与性质

- 二叉树：二叉树是每个结点最多有两个子树的树结构；
- 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。叶子只能出现在最下一层。非叶子结点的度一定是2；
- 完全二叉树：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下层的叶结点集中在靠左的若干位置上，这样的二叉树称为完全二叉树。叶子结点只能出现在最下两层。最下层的叶子一定集中在左部连续位置。倒数第二层，若有叶子结点，一定都在右部连续位置。同样结点树的二叉树，完全二叉树的深度最小。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。完全二叉树去掉最后一层就是满二叉树；
- 结点数与叶子数的关系：

#### 二叉树的遍历与实现

- 二叉树的存储结构一般采用链式存储结构。即二叉链表，不是数组，使用指针索引。
- 遍历方式有四种：前序遍历、中序遍历、后序遍历、层序遍历，顺序是对于根结点而言。
- 实现二叉树时，如果使用迭代，必须知道树有所深，因此使用递归实现，前序遍历。
- 使用递归时，需要设置递归终止条件，如所有的叶子结点指向 NULL 。
- 为了把一个递归过程改为非递归过程，就需要自己维护一个辅助栈结构，记录遍历时的回退路径。非递归的快速排序的设计依据也是这个。

~~~c
typedef char ElemType;

typedef struct BiTNode
{
	ElemType data;
	struct BiTNode *lchild, *rchild; // 左子树、右子树 
} BiTNode, *BiTree;

// 生成二叉树 
void CreateBiTree( BiTree *T )
{
	char c;
	scanf("%c", &c);
	
	if ( ' ' == c ) // 递归终止条件 
	{
		*T = NULL; // 所有的叶子结点指向 NULL 
	}
	else // 递归 
	{
		*T = (BiTNode*)malloc(sizeof(BiTNode)); // 创建结点 
		(*T)->data = c;
		CreateBiTree(&((*T)->lchild));
		CreateBiTree(&((*T)->rchild));
	}
}

// 访问二叉树结点的具体操作，level参数可以不要
void visit( char c, int level )
{
	printf("%c 位于第 %d层\n", c, level);
}

// 前序遍历 
void PreOrderTraverse( BiTree T, int level )
{
//	若二叉树为空，遍历结束
	if ( T ) //  指针不为空。遍历顺序：根左右  
	{
		visit(T->data, level); 
		PreOrderTraverse(T->lchild, level+1);
		PreOrderTraverse(T->rchild, level+1);
	}
}

int main()
{
	int level;
	BiTree T = NULL; // T表示二叉树。树的地址
	CreateBiTree(&T); // AB D  CE   ;
	
	level = 1;
	PreOrderTraverse(T, level);
	
	return 0;
}
~~~

#### [线索二叉树](https://blog.csdn.net/u014492609/article/details/40477795)

二叉树叶子结点的空指针浪费空间。对于完全二叉树，中序遍历每隔一个可以存放前驱与后继结点。

因此需要识别存放指针还是存放线索。存线索指的是存放前驱或后继。

**有了线索二叉树后，对它进行遍历时，其实就等于操作一个双向链表结构。**因此，如果所用的二叉树需要经过遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。

标记ltag与rtag取值为0或1。为0时表示有孩子。为1时表示是叶子结点，存在空指针。如：

- ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。
- rtag为0时指向该结点的右孩子，为1时指向该结点的后继。
- 借助标记完成二叉树中序遍历的迭代实现。

![img](https://img-blog.csdn.net/20141026171202062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ5MjYwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

~~~c
// 线索存储标志位
// Link(0)：表示指向左右孩子的指针
// Thread(1)：表示指向前驱后继的线索
typedef enum {Link, Thread} PointerTag;

typedef struct BiThrNode
{
	char data;
	struct BiThrNode *lchild, *rchild;
	PointerTag ltag, rtag;
} BiThrNode, *BiThrTree;

// 全局变量，始终指向刚刚访问过的结点
BiThrTree pre;

// 创建一棵二叉树，约定用户遵照前序遍历的方式输入数据
void CreateBiThrTree( BiThrTree *T )
{
	char c;

	scanf("%c", &c);
	if( ' ' == c )
	{
		*T = NULL;
	}
	else
	{
		*T = (BiThrNode *)malloc(sizeof(BiThrNode));
		(*T)->data = c;
		(*T)->ltag = Link;
		(*T)->rtag = Link;

		CreateBiThrTree(&(*T)->lchild);
		CreateBiThrTree(&(*T)->rchild);
	}
}

// 中序遍历线索化
void InThreading(BiThrTree T)
{
	if( T )
	{
		InThreading( T->lchild );		// 递归左孩子线索化

		if( !T->lchild )	// 如果该结点没有左孩子，设置ltag为Thread，并把lchild指向刚刚访问的结点。
		{
			T->ltag = Thread;
			T->lchild = pre; // 前驱变量
		}

		if( !pre->rchild )
		{
			pre->rtag = Thread;
			pre->rchild = T;
		}

		pre = T;

		InThreading( T->rchild );		// 递归右孩子线索化
	}
}
 
// 构造头指针，pre初始化
// 头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点
void InOrderThreading( BiThrTree *p, BiThrTree T )
{
	*p = (BiThrTree)malloc(sizeof(BiThrNode));
	(*p)->ltag = Link;
	(*p)->rtag = Thread; // 线索
	(*p)->rchild = *p;
	if( !T ) // 空树
	{ 
		(*p)->lchild = *p; // 指向本身
	}
	else
	{ 
		(*p)->lchild = T; // 指向二叉树根节点
		pre = *p; // 初始化赋值
		InThreading(T);
		
		pre->rchild = *p; // pre指向最后一个叶子结点
		pre->rtag = Thread;
		(*p)->rchild = pre;
	}
}

void visit( char c )
{
	printf("%c", c);
}

// 中序遍历二叉树，非递归
void InOrderTraverse( BiThrTree T )
{
	BiThrTree p;
	p = T->lchild;

	while( p != T )
	{
		while( p->ltag == Link )
		{
			p = p->lchild;
		}
		visit(p->data);

		while( p->rtag == Thread && p->rchild != T )
		{
			p = p->rchild;
			visit(p->data);
		}
		
		p = p->rchild;
	}
}

int main()
{
	BiThrTree P, T = NULL; // 二叉树根节点

	CreateBiThrTree( &T );
	InOrderThreading( &P, T );

	printf("中序遍历输出结果为: ");
	InOrderTraverse( P );
	printf("\n");

	return 0;
}
~~~

#### 赫夫曼树

- 赫夫曼编码：Huffman 是首个实用的数据无损压缩解决方案。赫夫曼编码基于赫夫曼树构成。

- 带权结点：二叉树叶子结点带权，树结点间的连线相关的数叫做权 Weight。也可以理解为长度或重量。
- 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。在一条路径中，每经过一个结点，路径长度都要加 1 。

- 树的带权路径长度 WPL：Weighted Path Length 是树中所有叶子结点的带权路径长度之和。WPL的值越小，说明构造出来的二叉树性能越优。**赫夫曼树就是最优二叉树。**
- 定长编码：如ASCII编码。频率高的字符占用大量内存。
- 变长编码：单个编码的长度不一致，可以根据整体出现频率来调节。频率高的字符长度短。
- 前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀，设计长短不等的编码。前后不会冲突。由哈夫曼树求得的编码为最优前缀码。每个叶子表示的字符的编码，就是从根到叶子的路径上的标号依次相连所形成的编码，显然这就是该字符的最优前缀码。变长编码可能使解码产生二义性，而前缀码的出现很好地解决了这个问题。

如用于解决远距离通信(电报)的数据传输的最优化问题。对于文字内容”ABCDEF”，赫夫曼编码的步骤包括：

1. 原编码二进制串：通过二进制数据表示如下。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171121142639266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd19saW51eA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

2. 构造哈夫曼树：因为每个字母的出现频率是不同的，假设给每个字母分配权值：A：27，B：8，C：15，D：15，E：30，F：5，首先按照它们的权值进行构造哈夫曼树。每次选择权值最小和次小的根结点，作为左右子树合并为一棵新的树。如下所示：

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171121142722555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd19saW51eA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3. 编码：将所有权值左分支改为0，右分支改为1，进行编码。求得每个字符的哈夫曼编码，有了每个字符的哈夫曼编码，我们就可以制作一个该字符集的哈夫曼编码表。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171121142745261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd19saW51eA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

4. 新编码二进制串：得到相应字符的的传输数据。同时，可以根据赫夫曼树实现解码。其过程是：依次读入文件的二进制码，从赫夫曼树的根结点出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子时便译出相应的字符。然后重新从根出发继续译码，直至文件结束。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171121142842112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd19saW51eA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 图

 #### 概念

- 线性表中我们把数据元素叫元素，树中叫结点，在图中数据元素我们则称之为顶点(Vertex)；
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的；
- 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G{V,E}，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合；
- 无向边(Edge)，用无序偶(Vi,Vj)来表示。有向边称为弧(Arc)，用有序偶<Vi,Vj>来表示，Vi称为弧尾，Vj称为弧头。**箭头从弧尾指向弧头**；
- 有些图的边或弧带有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)，带权的图通常称为网(Network)；
- 顶点V的度(Degree)是和V相关联的边的数目，记为TD(V)；
- 从顶点V1到顶点V2的路径(Path)的长度是路径上的边或弧的数目；
- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图(ConnectedGraph)；
- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边；
- 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。

#### 图的存储结构--邻接矩阵

- 图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。

- 无向图不分行列，边数组arc[4] [4]为对称矩阵（0表示不存在顶点间的边，1表示顶点间存在边）。

- 有向图分行列，边数组arc[4] [4]是非对称矩阵。
- 每条边上带有权的图就叫网（是无穷值代表没边，其它的话代表权值）。

~~~c
#define MAXVEX 100					// 最大顶点数
#define INFINITY 65535				// 用65535来代表无穷大

typedef char VertexType;			// 顶点类型应由用户定义
typedef int EdgeType;				// 边上的权值类型应由用户定义

typedef struct Graph
{
	VertexType vexs[MAXVEX];		// 顶点表 
	EdgeType arc[MAXVEX][MAXVEX];	// 邻接矩阵 
	int numVertexs, numEdges;		// 图中当前的顶点数和边数
} Graph;

void CreateGraph(Graph *G)
{
	printf("请输入顶点数与边数：\n");
	scanf("%d %d", &(G->numVertexs), &(G->numEdges));
	
	int i, j;
	
	// 顶点表赋值 
	printf("请输入顶点字符：\n");
	getchar(); 
	for ( i=0; i<G->numVertexs; i++ )
	{
		scanf("%c", &(G->vexs[i])); // 输入字符之间无空格 
	} 
	
	// 初始化
	for ( i=0; i<G->numVertexs; i++)
	{
		for ( j=0; j<G->numVertexs; j++ )
		{
			G->arc[i][j] = INFINITY;
		}
	}
	
	VertexType startVertex, endVertex;
	int startIndex, endIndex;
	int weight;
	
	// 邻接矩阵赋值
	printf("请输入起始与结束顶点字符以及权重：\n"); // (V1, V2)
	getchar(); 
	for ( i=0; i<G->numEdges; i++ )
	{
		scanf("%c %c %d", &startVertex, &endVertex, &weight);
		getchar();	// 输入完按下回车键，回车键\n会影响给下一次scanf()
		
		// 查找顶点所在位置，即邻接矩阵的行与列 
		for ( j=0; j<G->numVertexs; j++ )
		{
			if ( startVertex == G->vexs[j] )
			{
				startIndex = j;
			} 
			if ( endVertex == G->vexs[j] )
			{
				endIndex = j;
			}
		}
		
		G->arc[startIndex][endIndex] = weight;
//		如果是无向图，需要双向保存
		G->arc[endIndex][startIndex] = weight; 
	}
}
~~~

#### 图的存储结构--邻接表

- 对于稀疏图（节点多，连边少），寻找一个点能连到的所有点代价非常大，需要把矩阵整个一行都遍历一遍。此外，邻接矩阵的存储需要空间也恒定为点数量的平方，对于稀疏图而言，矩阵中会存在大量0表示两个点之间没有连线，这样会存在非常大的空间浪费。

- 图的邻接表存储方式是将数组与链表结合。一个一维数组存储图中顶点信息，称为**顶点表**，另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。

- 用单链表存储顶点的邻接点。由于邻接点的个数不定，所以用单链表存储，无向图称为顶点的**边表**，有向图称为顶点作为弧尾的出边表。缺点是不能沿着边反着找，因此当要求弧头时需要建立逆邻接表。

如图所示是无向网图：

![img](https://img-blog.csdn.net/20180508185647682?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQzMTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上图中a-c之间也有条边，权重为2。

邻接表中数据的存储图示如下：

![img](https://img-blog.csdn.net/20180508193352978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQzMTAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

~~~c
//邻接表的时间复杂度：n为顶点数，e为边数 O（n + e） 
#define MAXVEX 100

typedef char VertexType;		// 顶点类型应由用户定义
typedef int EdgeType;			// 边上的权值类型应由用户定义

typedef struct EdgeNode			// 边表结点 
{
	int adjvex;					// 邻接点域，存储该顶点对应的下标
	int weight;					// 用于存储权值
	struct EdgeNode *next;		// 链域，指向下一个邻接点
} EdgeNode;

typedef struct VertexNode 		// 顶点结点 
{
	VertexType data;			// 存储顶点数据的信息
	struct EdgeNode *first;		// 边表头指针
} VertexNode, AdjList[MAXVEX];

typedef struct					// 图 
{
	AdjList adjList;			// 定义邻接表
	int numVertexs;				// 当前邻接表的顶点数
	int numEdges;				// 当前邻接表的边数
} GraphAdjList;			

void CreateALGraph( GraphAdjList *G )
{
	printf("请输入顶点数与边数：\n");
	scanf("%d %d", &(G->numVertexs), &(G->numEdges));
	
	int i;
	
	printf("请输入顶点字符：\n");
	getchar();
	for ( i=0; i<G->numVertexs; i++ )
	{
		scanf("%c", &(G->adjList[i].data));	// G->adjList[i]是值，不是地址
		G->adjList[i].first = NULL;
	}
	
	int j, k, m;
	EdgeNode *e;
	
	printf("请输入边(Vi,Vj)上的下标i,下标j以及权重：\n");
	getchar();
	for ( i=0; i<G->numEdges; i++ )
	{
		scanf("%d %d %d", &j, &k, &m);
		
		e = (EdgeNode*)malloc(sizeof(EdgeNode)); 
		e->adjvex = k;
		e->weight = m;
		e->next = G->adjList[j].first; // 单链表头插法 
		G->adjList[j].first = e;
		
		e = (EdgeNode*)malloc(sizeof(EdgeNode)); 
		e->adjvex = j;
		e->weight = m;
		e->next = G->adjList[k].first; // 无向图双向保存
		G->adjList[k].first = e;
	}
}

void PrintALGraph(GraphAdjList G)
{
	int i;
	for ( i=0; i<G.numVertexs; i++ )
	{
		EdgeNode *e = G.adjList[i].first;
		printf("%c\t", G.adjList[i].data);
		while ( e )
		{
			printf("%d %d\t", e->adjvex, e->weight);
			e = e->next;
		}
		printf("\n");
	}
}
~~~

#### 图的存储结构--十字链表

优化有向图的存储结构。十字链表(Orthogonal List)把邻接表和逆邻接表整合在了一起。这样既容易找到以Vi为尾的弧，也容易找到以Vi为头的弧，因而容易求得顶点的出度和入度。

#### 深度优先遍历

图的遍历，按照一定的原则逐一访问，满足不重不漏的原则。

深度优先遍历(DepthFirstSearch)，也有称为深度优先搜索，简称为DFS。类似于回溯法，一条路走到黑。

两种实现方式，基于邻接矩阵与基于邻接表。

类似于树的前序遍历。可以借助栈实现。

~~~~c

~~~~

#### 骑士周游问题

国际象棋的棋盘为8*8的方格棋盘，现将“马”放在任意指定的方格中，按照“马”走棋的规则将“马”进行移动。要求每个方格只能进入一次，最终使得“马”走遍棋盘64个方格，用1~64来标注“马”移动的路径。

哈密尔顿路径指的是经过图中每个顶点，且只经过一次的一条轨迹。如果这条轨迹是一条闭合的路径（从起点出发不重复地遍历所有点后仍能回到起始点），那么这条路径称为哈密尔顿回路。

涉及到递归、回溯。

~~~c

~~~

#### 广度优先遍历

广度优先遍历（BreadthFirstSearch），又称为广度优先搜索，简称BFS。采用逐步扩大查找的范围的方式。

类似于树的层序遍历。

广度优先遍历需要借助于另外的数据结构队列。当把图中的顶点放到队列中时，表示这个顶点被遍历了（可以把顶点的值打印出来）。

~~~c
// 实现不使用递归，使用队列 
void BFSTraverse( MatrixGraph G )
{
	int i, j;
	for ( i=0; i<G.numVertexs; i++ )
	{
		visited[i] = FALSE;
	}
	
	Queue Q;
	InitQueue(&Q);
	
	i = 0; // 起点 
	printf("%c\t", G.vexs[i]);
	visited[i] = TRUE;
	EnQueue(&Q, i);
	
	while ( !QueueEmpty( Q ) ) // 队列非空 
	{
		DeQueue(&Q, &i);
//		printf("\ni=%d, %c出队列\n", i, G.vexs[i]);
		for ( j=0; j<G.numVertexs; j++ ) // 邻接矩阵的第i行 
		{
			if ( 1 == G.arc[i][j] && !visited[j] )
			{
				printf("%c\t", G.vexs[j]);
				visited[j] = TRUE;
				EnQueue(&Q, j);
			} 
		}
	}
}
~~~

#### [迪杰斯特拉算法](https://blog.csdn.net/qq_35644234/article/details/60870719)

从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径。

逐个顶点计算，贪心算法。

如图所示，要求V0到V8的最短路径时并不是一下子就求出了V0到V8的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到要的结果。

![1572244271891](C:\Users\HMZ\AppData\Roaming\Typora\typora-user-images\1572244271891.png)

~~~c
typedef int Patharc[MAXVEX];			// 用于存储最短路径下标的数组 
typedef int ShortPathTabel[MAXVEX];		// 用于存储到各点最短路径的权值和

void ShortestPath_Dijkstra( MGraph G, int start, Patharc *P, ShortPathTabel *D )
{
	int final[MAXVEX];					// final[w] = 1 表示已经求得顶点V0到Vw的最短路径，0为没有找到
	int i, j, k, min;
	
	// 初始化 
	for ( i=0; i<G.numVertex; i++ )		
	{
		(*D)[i] = G.arc[start][i];		// 将与V0点有连线的顶点加上权值
		(*P)[i] = 0;					// 初始化路径数组P为0
		final[i] = 0;					// 全部顶点初始化为未找到最短路径
	} 
	
	// 起点 
	final[start] = 1;					// V0至V0的路径为0
	(*D)[start] = 0;					// V0至V0不需要求路径
	
	// 开始主循环，每次求得V0到某个Vv顶点的最短路径
	for ( i=0; i<G.numVertex; i++ )
	{
		min = INFINITY;
		
		// 选择最小权值和的顶点k作为下一个点。贪心算法 
		for ( j=0; j<G.numVertex; j++ )
		{
			if ( !final[j] && (*D)[j] < min )
			{
				min = (*D)[j];
				k = j;
			}
		}
		final[k] = 1;					// 将目前找到的最近的顶点置1
		
		// 对与k顶点连通的顶点进行松弛处理。修正当前最短路径及距离
		for ( j=0; j<G.numVertex; j++ )
		{
			if ( !final[j] && (min + G.arc[k][j]) < (*D)[j] )
			{
				(*D)[j] = min + G.arc[k][j];		// 修改当前路径长度。经过判断后不走V0->V2		
				(*P)[j] = k;						// 存放前驱顶点。如V0->V1->V2
			} 		
		}
	}
	
	// 打印测试 
	printf("final:\n");
	for ( i=0; i<G.numVertex; i++ )
	{
		printf("%d\t", final[i]);
	}
	printf("\n");
}
~~~





## 查找与排序

### 查找



#### 散列表（哈希表）查找

1. 概念

- 顺序表与有序表的查找都需要比较。各个记录之间存在逻辑关系；

- 散列表不需要进行比较与迭代。各个记录之间不存在逻辑关系。

散列表是**在记录的存储位置与它的关键字之间建立一个确定的对应关系f（哈希函数）**，使得每一个关键字key对应一个存储位置f(key)。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（hash table）。**哈希表简单来说就是一张带索引和存储空间的表。**适用于一对一的查找。缺点是key与value都不可以重复。

2. 散列函数的构造

基本原则：计算简单、散列地址分布均匀。

- 直接定址法：取关键字的某个线性函数值作为散列地址，即：f(key) = a * key + b，适用于知道关键字分布同时位数较小；
- 数字分析法：适合处理关键字位数比较大的情况，如抽取手机号的后四位作为真正的用户编号作为散列地址；
- 平方取中法：将关键字平方之后取中间若干位数字作为散列地址，适用于不知道关键字分布，但位数较小；
- 除留余数法：最常用的构造散列函数方法，对于长度为m的散列函数计算公式为：f(key) = key mod p(p<=m)。p的选择是关键，需要解决冲突；
- 随机数法：取关键字的随机函数值作为散列地址，即：f(key) = random(key)。适用于关键字长度不等的情况，如字符串。

3. 处理散列冲突的方法

冲突：当 key1 != key2时，f(key1) == f(key2)。 

- 开放地址法：散列表足够大，发生冲突时，寻找下一个空的散列地址。公式：fi(key) = (f(key)+di) mod m (di=1^2, -1^2, 2^2, -2^2…, q^2, -q^2,q<=m/2)，设置位移量di的取值方法可以解决堆积问题；
- 再散列函数：公式：fi(key) = RHi(key) (i=1, 2…k)，多个散列函数；
- 公共溢出区法：有两张表，基本表与溢出表。

4. 散列表查找实现代码

~~~c
#define HASHSIZE 12
#define NULLKEY -32768

typedef struct
{
	int *elem;	// 数据元素的基址，动态分配数组
	int count;	// 当前数据元素的个数
}HashTable;

int InitHashTable(HashTable *H)
{
	H->count = HASHSIZE;
	H->elem = (int *)malloc(HASHSIZE * sizeof(int));
	if( !H->elem ) // 申请空间失败
	{
		return -1;
	}
	for( i=0; i < HASHSIZE; i++ ) // 初始化默认值
	{
		H->elem[i] = NULLKEY;
	}
	return 0;
}

// 散列函数使用除留余数法
int Hash(int key)
{
	return key % HASHSIZE;
}

// 插入关键字到散列表
void InsertHash(HashTable *H, int key)
{
	int addr;
	
	addr = Hash(key); // 最简单的偏移地址
	
	while( H->elem[addr] != NULLKEY )	// 如果不为空，则冲突出现
	{
		addr = (addr + 1) % HASHSIZE;	// 开放定址法的线性探测
	}
	
	H->elem[addr] = key;
}

// 散列表查找关键字。查到返回0，没查到返回-1
int SearchHash(HashTable H, int key, int *addr)
{
	*addr = Hash(key); // 查找效率 O(1)
	
	while( H.elem[*addr] != key ) // 冲突，使用开放定址法线性探测的逆运算
	{
		*addr = (*addr + 1) % HASHSIZE;
		if( H.elem[*addr] == NULLKEY || *addr == Hash(key) ) // 查到最后或者返回原点说明不存在
		{
			return -1;
		}
	}
	
	return 0;
}
~~~

#### Python字典实现

对key进行hash的时候，不同的key可能hash出来的结果是一样的，尤其是数据量增多的时候，这个问题叫做哈希冲突。如果解决这种冲突情况呢？通常的做法有两种，一种是链接法，另一种是开放寻址法，Python选择后者。

开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个**探测函数**计算出下一个候选位置，如果下一个获选位置还是有冲突，那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。

字典中的一个key-value键值对元素称为entry（也叫做slots），对应到Python内部是PyDictEntry，PyDictObject就是PyDictEntry的集合。

entry有三种状态，其中Dummy是一种类似的伪删除方式，保证探测链的连续性。



<https://www.cnblogs.com/nelsen-chen/p/9073004.html>

<https://www.hongweipeng.com/index.php/archives/1230/>

<https://blog.csdn.net/qq_33339479/article/details/90446988>

内存布局如图所示：

![python_dict_mem](https://img-blog.csdnimg.cn/20190522164306274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzM5NDc5,size_16,color_FFFFFF,t_70)



### 排序

**内部运算包括比较与交换。**

通常将数据元素称为记录。

稳定排序是指相等的数排序完成后，其顺序保持不变。

有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数

如班级同学已经按照学号排好序了。现在要按照身高排序。如果是稳定排序排好之后，身高相同的同学，还是按照学号顺序的。

#### 冒泡排序

- 两两比较相邻记录。每一轮从前往后取出最大值放在末尾，或**从后往前每次将最小值放在头部**；

- 对于原数列顺序的情况可以设置flag进行优化，可以减少比较的次数。

~~~c
void BubbleSort( int list[], int n )
{
	int i, j;
	int temp;
	int count1 = 0, count2 = 0; // 设置计数器 
	int flag = 1; // 优化2 
	
//	int length = sizeof(list) / sizeof(list[0]); // func, 8, 4
//	printf("%d, %d\n", sizeof(list), sizeof(list[0])); // main, 20, 4
//	int len; // 优化1，从后往前时不需要该变量 
//	len = n;
	
	for ( i=0; i<n-1 && flag; i++ )
	{
		flag = 0;
//		for ( j=0; j<len-i,; j++)
		for ( j=n-1; j>i; j-- ) // 优化1 
		{
//			flag = 0; // 位置错误，如[1,5,3,4]。循环只执行一次 
			count1++; // 记录比较次数 
			if ( list[j-1] > list[j] )
			{
				flag = 1;
				count2++; // 记录交换次数 
				temp = list[j-1];
				list[j-1] = list[j];
				list[j] = temp;
			}
		}
	}
	
	printf("总共进行了 %d 次比较与 %d 次交换\n", count1, count2);
}
~~~

#### 选择排序

- 冒泡排序交换次数较多。选择排序每一轮只进行最多一次的交换，相应比较次数增多；
- 左边为有序区，右边为无序区。开始时数组第一个元素为有序区，其余为无序区。**每轮选出无序区的最小值**，放入左边的有序区。也就是说**比较发生在无序区**。
- 当**记录本身基本有序**时，选择排序的算法复杂度依然较高。

~~~c
void SelectSort( int list[], int n )
{
	int i, j, min, temp, count1 = 0, count2 = 0;
	
	for ( i=0; i<n-1; i++ ) // i之前为有序区，循环终止条件为 j<n-1
	{
		min = i;
		
		for ( j=i+1; j<n; j++ ) // 循环终止条件为 j<n 而非 j<n-1 
		{
			count1++;
			if ( list[j] < list[min] )
			{
				min = j;
			}
		}
		
		count1++;
		if ( min != i ) // 交换
		{
			count2++;
			temp = list[i];
			list[i] = list[min];
			list[min] = temp;
		}
	}
	
	printf("总共进行了 %d 次比较与 %d 次交换\n", count1, count2);
}
~~~

#### 插入排序

插入排序类似于扑克牌的排序。如图所示：

![img](http://img2.jintiankansha.me/get?src=http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqO8FHelyxqpuVHsnh1LYMUxkrjfgeiasys1E2eWDPt1Ouxg5ibB8Kia1s1wD3ndwlB8ZfckWJ7rvEyg/640?wx_fmt=png)

- 左边为有序区，右边为无序区。开始时数组第一个元素为有序区，其余为无序区。**每轮取无序区的第一个元素**，放入有序区的正确位置。也就是说**比较发生在有序区**；
- 每轮操作时并不需要真的进行完整交换，只需把较小的元素暂存起来，再**把有序区的元素从右向左逐一复制**，减少不必要的交换；
- 当**记录本身基本有序或记录数少**时，插入排序的算法复杂度低。插入排序是简单排序算法中性能最好的。

插入排序的整个过程如图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqO8FHelyxqpuVHsnh1LYMUJ0diaufsf1ib5gemtETiaM2PGIOarKG8EXdCibPciadcTrhLDnc9AibxSeIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

~~~c
void InsertSort( int list[], int n )
{
	int i, j, temp;
    
//	for ( i=0; i<n-1; i++ ) 
//	{
//		for ( j=i+1; j>0; j-- )
//		{
//			count1++;
//			if ( list[j-1] > list[j] )
//			{
//				count2++;
//				temp = list[j-1];
//				list[j-1] = list[j];
//				list[j] = temp;
//			}
//		}
//	}

	// 优化，较少不必要的交换
	for ( i=1; i<n; i++ ) // i之前为有序区，循环 i从1 开始
	{
		if ( list[i] < list[i-1] )
		{
			temp = list[i]; // 将较小的数取出，之后将放在正确的位置上 
			
			for ( j=i-1; list[j]>temp; j-- ) // 向后移动，不需要交换 
			{
				list[j+1] = list[j];
			}
			
			list[j+1] = temp; // j--后空出来的位置 
		}
	}
}
~~~

#### 希尔排序

- **插入排序的升级版，又称分组排序**；
- 希尔排序就是将原始记录分组进行直接插入排序，满足插入排序记录本身基本有序或记录数少的条件时，算法复杂度低。

分组排序的整个过程如图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqsibZKNKicWRt2hhnA33uicax62oSibOcGdtFhroOUzP1tkLvgaJ35y14WTk4FqlgoAiaw6cOGFoaSUeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

~~~c
void ShellSort( int list[], int n )
{
	int i, j, temp;
	int gap;
	
	for ( gap=n/2; gap>0; gap/=2 ) // N * log(N)
	{
		for ( i=gap; i<n; i++ ) // 下面与插入排序完全相同
		{
			if ( list[i] < list[i-gap] )
			{
				temp = list[i]; // 将较小的数取出，放在正确的位置上 
				
				for ( j=i-gap; list[j]>temp; j-=gap ) // 向后移动，不需要交换 
				{
					list[j+gap] = list[j];
				}
				
				list[j+gap] = temp; // i--后空出来的位置 
			}
		}
	}
}
~~~

#### 堆排序



#### 归并排序

归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

归并排序和擂台赛原理类似，**不同之处在于归并排序要求确定每一个元素的排列位置**。如图所示是擂台赛。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGp1RK1yWHsdYu87dGxGEm6LX7iauLZBrusOn5LsTkcBlgxDcJNY89a9ibtOquptgkYFBBmAAL18ZFlQ/640?wx_fmt=png)

假设集合一共有n个元素，算法将会对集合进行逐层的折半分组。一直到每组只有一个元素为止。当每个小组内部比较出先后顺序以后，小组之间会展开进一步的比较和排序，合并成一个大组；大组之间继续比较和排序，再合并成更大的组......最终，所有元素合并成了一个有序的集合。归并排序的核心是把两个有序的小集合归并成一个有序的大集合。

**归并排序分两步，先分组后合并**，如图所示。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

打印程序执行过程：

![1573647769820](C:\Users\HMZ\AppData\Roaming\Typora\typora-user-images\1573647769820.png)

- 递归实现：先从下往上分组，再从下往上进行比较与合并；

~~~c
#define MAXSIZE 10

// 实现归并，并将最后的结果存放在list1中 
// 归并排序的核心是把两个有序的小集合归并成一个有序的大集合。
void merging( int *list1, int list1_size, int *list2, int list2_size )
{
	int temp[MAXSIZE];
	int i, j, k;
	i = j = k = 0;
	
	// 两数组比较
	while ( i < list1_size && j < list2_size )
	{
		if ( list1[i] > list2[j] )
		{
			temp[k++] = list2[j++];
		}
		// else if ( list1[i] <= list2[j] ) // 添加等号
        else
		{
			temp[k++] = list1[i++];
		}
	}
	
	// 两数组比较结束后其中一个末尾有剩余 
	while ( i < list1_size )
	{
		temp[k++] = list1[i++];
	}
	
	while ( j < list2_size )
	{
		temp[k++] = list2[j++];
	}
	
	// list1数组保存排序后结果 
	for ( i=0; i<list1_size+list2_size; i++ )
	{
		list1[i] = temp[i];
	}
}

// 归并排序分两步，先分组后合并
void MergeSort( int list[], int n )
{
	if ( n > 1 ) // 递归结束条件，每个数组一个元素 
	{
		// 一个数组分成两个小数组 
		int *list1 = list;
		int list1_size = n / 2;
		int *list2 = list + n / 2;
		int list2_size = n - list1_size; // 个数可能是奇数
		
		MergeSort( list1, list1_size ); // 分组 
		MergeSort( list2, list2_size ); // 分组 
		
		merging( list1, list1_size, list2, list2_size ); // 比较与合并 
	}
}
~~~

- 迭代实现



#### 快速排序

- 冒泡排序的升级版，都属于交换排序，通过元素之间的比较与交换位置达到排序的目的。快速排序使得元素移动的间距增大，减少比较与移动的次数；
- 不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列另一边，从而将数列拆解成两个部分。在分治法的思想下，以基准点为中心，原数列在每一轮被拆分为两部分，每一部分在下一轮又被拆分成两部分，直到不可再分为止。
- 核心包括两步：选择基准点、元素的移动。过程如图所示。代码使用递归实现。

![img](https://img-blog.csdn.net/20180823114958402?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhb2Zlbmd0YW8xMzE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

~~~c
// 实现交换 
void swap( int list[], int low, int high )
{
	int temp;
	
	temp = list[low];
	list[low] = list[high];
	list[high] = temp;
}

// 指针交换法实现元素的移动 
int partition( int list[], int low, int high )
{
	int pivot = list[low]; // 将第一个元素作为基准点。在该函数内保持不变。希望存储的是中间的值 
	int startindex = low; // 备份用于每轮最后的移动，将基准点移动到正确的位置 
	
	while ( low < high )
	{
//		必须要有 low < high 
		while ( low < high && list[high] >= pivot ) // 过滤掉右边比基准点大的元素
		{
			high--; // 指针左移
		}
//		swap( list, low, high); // 交换。属于挖坑法，存在不必要的交换 
		
		while ( low < high && list[low] <= pivot ) // 过滤掉左边比基准点小的元素
		{
			low++; // 指针右移
		}
		swap( list, low, high); // 交换
		
//		测试 
//		int i;
//		for ( i=0; i<8; i++ )
//		{
//			printf("%d ", list[i]);
//		}
//		printf("\n");
		
//		if ( low < high )
//		{
//			swap(list, low, high); // 交换
//		}
	}
	swap( list, startindex, low); // 将基准点移动到正确的位置
	
	return low; // 返回新的基准点
}

void QSort( int list[], int low, int high )
{
	int pivot = list[low]; // 基准点

	if ( low < high ) // 当指针重叠时完成了一轮比较
	{
		pivot = partition( list, low, high ); // 计算基准点的函数，返回新的基准点
		
		QSort( list, low, pivot-1); // 基准点左边
		QSort( list, pivot+1, high); // 基准点右边
	}
}

void QuickSort( int list[], int n ) // 为了与其他排序算法保持格式的统一
{
	QSort(list, 0, n-1);
}
~~~

#### 快速排序的优化

- 快速排序的优化：基准点的优化选取（三数取中法）、优化不必要的交换（交换变赋值）、优化小数组排序（插入排序）、优化递归操作（尾递归）；
- 快速排序适用于大规模数组。插入排序是简单排序算法中性能最好的。临界值为7。

~~~c
int partition( int list[], int low, int high )
{
//	优化1：优选基准点。交换的目的是使high取最大，low取中间值 
	int mid = low + ( high - low ) / 2;
	if ( list[low] > list[high] ) // list[low] < list[high]
	{
		swap( list, low, high );
	} 
	if ( list[mid] > list[high] ) // list[mid] < list[high]
	{
		swap( list, mid, high );
	}
	if ( list[mid] > list[low] ) // list[mid] < list[low]
	{
		swap( list, mid, low);
	}
	
	int pivot = list[low]; // 将第一个元素作为基准点。在该函数内保持不变。希望存储的是中间的值 
	int startindex = low; // 备份用于每轮最后的移动，将基准点移动到正确的位置 
	
//  优化2：变交换为赋值操作
	while ( low < high )
	{
//		必须要有 low < high 
		while ( low < high && list[high] >= pivot ) // 过滤掉右边比基准点大的元素
		{
			high--; // 指针左移
		}
		list[low] = list[high]; // 变交换为赋值操作 
		
		while ( low < high && list[low] <= pivot ) // 过滤掉左边比基准点小的元素
		{
			low++; // 指针右移
		}
		list[high] = list[low];
	}
	list[low] = pivot; 
	
	return low; // 返回新的基准点
}

// 优化3：结合使用快速排序与插入排序
#define MAX_LENGTH_INSERT_SORT 7 // 快速排序与插入排序性能的临界点

// 简单插入排序 
void ISort( int list[], int n )
{
	int i, j;
	int temp = 0;
	
	for ( i=1; i<=n; i++ )
	{
		if ( list[i-1] > list[i] )
		{
			temp = list[i];
			for ( j=i-1; list[j]>temp; j-- )
			{
				list[j+1] = list[j];
			}
			list[j+1] = temp;
		}
	}
}

void InsertSort( int list[], int low, int high )
{
	ISort( list+low, high-low+1 );
}

void QSort( int list[], int low, int high )
{
	int pivot = list[low]; // 基准点

	if ( ( high - low ) > MAX_LENGTH_INSERT_SORT ) // 当指针重叠时完成了一轮比较
	{
		pivot = partition( list, low, high ); // 计算基准点的函数，返回新的基准点
		
		QSort( list, low, pivot-1); // 基准点左边
		QSort( list, pivot+1, high); // 基准点右边
	}
	else
	{
		InsertSort( list, low, high );
	}
}

// 优化4：尾递归，将两个递归修改为一个递归，缩减栈空间的使用，提高效率
void QSort( int list[], int low, int high )
{
	int pivot = list[low]; // 基准点

	if ( ( high - low ) > MAX_LENGTH_INSERT_SORT ) // 当指针重叠时完成了一轮比较
	{
		while ( low < high )
		{
			pivot = partition( list, low, high ); // 计算基准点的函数，返回新的基准点
			
			if ( pivot - low < high - pivot ) // 执行左边 
			{
				QSort( list, low, pivot-1); // 基准点左边
				low = pivot + 1; // 基准点右边
			}
			else // 执行右边 
			{
				QSort( list, pivot+1, high); // 基准点左边
				high = pivot - 1; // 基准点右边
			}
		}
	}
	else
	{
		InsertSort( list, low, high );
	}
}
~~~





