# 笔试

## 基础

### 进制

#### 进制转换



### 位运算

#### 判断奇数

判断一个数的奇偶性，不用取余和除法。使用按位与运算实现。

如十进制3的二进制为0011，十进制1的二进制为0001，按位与运算结果为0001，也就是十进制的1。

~~~c
if ( n & 1 )
{
	// 奇数
}
~~~

#### 两数相加

加法器。

#### ASCII

### 算法

#### 判断素数

#### 随机数生成

#### 洗牌算法

#### 数组全排列

## 数据库

### SQL
#### SQL 连接

SQL 左外链接、有外连接、全外连接之经典解释：

假设一堆男女在教堂，有夫妇有单身的，假设男为左表，女为右表；

教父说：结了婚的人请出去，结了婚的人请手拉手，于是结了婚的男女站了起来，这就是INNER内连；

教父说：男的并且和这些男的结婚的女的请出去,结了婚的人请手拉手，于是，结了婚的夫妇手拉手出去，单身的男的也出去了。这就是LEFT左连；

教父说：女的并且和这些女的结婚的男的请出去,结了婚的人请手拉手，于是，结了婚的夫妇手拉手出去，单身的女的也出去了。这就是RINGT右连；

教父又说：请全部人都出去，结了婚的人请手拉手，于是　结了婚的夫妇手拉手出去,单身的男的和女的各自出去了。这就是全外连。



#### 事务

事务指作为一个单元的一组有序的数据库操作，如果组中的所有操作都成功，则认为事务成功，即使有一个操作失败。事务也不成功，如果所有操作完成，事务提交，其修改将作用于所有其他数据库进程，如果有一个操作失败，则事务回滚，该事务影响到的操作都会取消。

为保证操作有效和业务逻辑的完整性，当一个业务逻辑中某条 sql 语句出错时，整个操作都退回。事务有四大特性（简称ACID）：

- 原子性（Atomicity）：操作不可分割
- 一致性（Consistency）：执行结果一致，与顺序无关

 * 隔离性（Isolation）：不受其他事务的干扰，加锁
 * 持久性（Durability）：对数据库的改变不丢失

要求数据库引擎类型必须是 innodb 或 bdb 类型。innodb查询速度慢，写入速度快。

当数据被更改时，可以使用事务。将原表一行锁起来，在内存级的临时表中进行更改。分为三种：

 * begin：开启事务，加锁
 * commit：更改生效，开锁
 * rollback：放弃更改，开锁

#### 索引

https://mp.weixin.qq.com/s/BoiY-5R5m0YRYR2IlOC90g

索引（Index）是帮助MySQL高效获取数据的数据结构。

数据库查询是数据库的最主要功能之一。但每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。

当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。所以可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。

MySQL普遍使用带有顺序访问指针的B+Tree实现其索引结构。B+树适合作为数据库的基础结构，也是因为适应计算机的内存-机械硬盘两层存储结构。B+树结构如图所示。

![img](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEdBOH4QQibh7a33yEfKgr6DAUeJNib38m0k1l8yWDXte9ZQJ24lsojzOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多）。

除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。

当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。

InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据。

在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置。

在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k。而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。

![img](https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEKSPz6ozRz2VTFyj2Qpnnia4aE4BTr69ibqDlrc3wA0LiamOqLdscEwWcw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 视图

### Redis

#### 数据存储类型

#### K-V存储原理

## 数据结构

### 链表



### 栈与队列

### 树

### 图

### 查找

### 排序

#### [冒泡排序](https://www.cnblogs.com/kilig/p/10423845.html)

1. 思想

冒泡排序的英文Bubble Sort，是一种最基础的**交换排序**。把相邻的元素两两比较，根据大小来交换元素的位置。

每一轮可以找到无序数组的最大值，就像是汽水里的小气泡一样漂啊漂，漂到了最右侧。数列最右侧的元素可以认为是一个有序区域。



2. 代码

3. 算法复杂度

#### [插入排序](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653199343&idx=1&sn=a5491fa908e45e6117423d9ba5062611&chksm=8c99e935bbee60232aacb7c2b74961a24e7b86d44bf98357c597ad277a8eb15639c1de7034d9&mpshare=1&scene=24&srcid=&sharer_sharetime=1571764900424&sharer_shareid=98a5c34fd80e29d03560a4baaa3a1d4b#rd)

1. 思想

给定无序数组如下：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqO8FHelyxqpuVHsnh1LYMUOpATQ1pfCs5mKkdJULaTEiayUGCGcXOeHIQQO6jZicU6lriaXqucuW0Vw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

把数组的首元素5作为有序区，此时有序区只有这一个元素：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqO8FHelyxqpuVHsnh1LYMUG1eTFLmNBY1yzSpdULicgYmt2vyBnAr9MjYiaA69D0W9Oj6wgue2MIcw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**维护一个有序区，接下来把元素一个一个插入到有序区的适当位置，直到所有元素有序为止。**

优化方法是不进行完整的比较与交换，而是将元素暂存，再把有序区的元素比较与复制，有序区的元素相应向后挪动，减少了许多无谓的交换。

因此插入排序一共会进行（数组长度-1）轮，每一轮的结果如下：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqO8FHelyxqpuVHsnh1LYMUJ0diaufsf1ib5gemtETiaM2PGIOarKG8EXdCibPciadcTrhLDnc9AibxSeIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2. 代码

3. 算法复杂度

- 由于插入排序一共会进行（数组长度-1）轮，因此最坏时间复杂度为O(n^2)；

- 由于插入排序是在原地进行排序，没有引入额外的数据结构，因此空间复杂度O(1)。
- 稳定性

4. 特点

- 在大多数元素已经有序的情况下，插入排序的工作量较小

这个结论很明显，如果一个数组大部分元素都有序，那么数组中的元素自然不需要频繁地进行比较和交换。

- 在元素数量较少的情况下，插入排序的工作量较小

这个结论更加显而易见，插入排序的工作量和n的平方成正比，如果n比较小，那么排序的工作量自然要小得多。

#### [希尔排序](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653199674&idx=1&sn=9ab7bb7e465104c67a3d8590ebd0fe6c&chksm=8c99efe0bbee66f69c07e5f423d7751c9667fa82beb6dcaef4c0e96dac9545d2277c8179c765&mpshare=1&scene=24&srcid=&sharer_sharetime=1571763402524&sharer_shareid=98a5c34fd80e29d03560a4baaa3a1d4b#rd)

1. 思想

**希尔排序是直接插入排序的升级版**。针对插入排序的特点，对原始数组进行预处理，使得原始数组的大部分元素变得有序。

对原始数据逐步分组进行粗调，再进行直接插入排序的思想，就是希尔排序，根据该算法的发明者，计算机科学家Donald Shell的名字所命名。

**分组插入排序**的整个过程如图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqsibZKNKicWRt2hhnA33uicax62oSibOcGdtFhroOUzP1tkLvgaJ35y14WTk4FqlgoAiaw6cOGFoaSUeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上面示例中所使用的分组跨度（4，2，1），被称为希尔排序的增量，增量的选择可以有很多种，我们在示例中所用的逐步折半的增量方法，是Donald Shell在发明希尔排序时提出的一种朴素方法，被称为希尔增量。当分组跨度为1时，也就等同于做直接插入排序。

希尔增量的缺点是每一轮希尔增量之间是等比的，因此希尔增量存在盲区。如下图所示，如果我们照搬之前的分组思路，无论是以4为增量，还是以2为增量，每组内部的元素都没有任何交换。一直到我们把增量缩减为1，数组才会按照直接插入排序的方式进行调整。

对于这样的数组，希尔排序不但没有减少直接插入排序的工作量，反而白白增加了分组操作的成本。

![img](https://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqsibZKNKicWRt2hhnA33uicaxDzukJw2obqA9qic3NcUzbTrnJyAUz31A2jkLGUcCB2d0d8RxXQPCSRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

为了保证分组粗调没有盲区，每一轮的增量需要彼此“互质”，也就是没有除1之外的公约数。

于是，人们相继提出了很多种增量方式，其中最具代表性的是Hibbard增量和Sedgewick增量。

2. 代码

3. 算法复杂度

- 算法的平均复杂度低于O(n^2)。但在极端条件下，希尔排序的最坏时间复杂度仍然是O(n^2)，甚至比插入排序更慢。

- 希尔排序是不稳定排序。

#### [归并排序](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653200029&idx=1&sn=51ecebafb9ff77baf3de71bdc4f67b78&chksm=8c99ec47bbee6551b0377b97e26670c4895d0c934051e4aa927e62bf9b64996b6e1f7459edfe&mpshare=1&scene=1&srcid=&sharer_sharetime=1571458438164&sharer_shareid=98a5c34fd80e29d03560a4baaa3a1d4b&key=042d6afab53eaf2e63c17281b6610ae7c63f774eabfbc8ad5027907ed50384a058caa7a76779f31dc6d030eaf2c8ab061586e9cf1be965890e10182bb1ee5bc33425197a07131e64ef8a6d64575047c9&ascene=1&uin=MjAyMjAzOTYxOQ%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=A2gGhtCQVHdgMi1dn69S0QtcmwLGDA%2Fzz1X%2BW5fS8vWEjNq3dP%2BPUfyHQ%2FwJw9Nm)

1. 思想



2. 代码

3. 算法复杂度

#### [快速排序](https://blog.csdn.net/libaineu2004/article/details/82253412)

1. 思想

快速排序从冒泡排序演变而来。

分治法



2. 代码

3. 算法复杂度



## 语言
### C
#### 标准输入输出

https://www.jianshu.com/p/580ddaca13d5
https://blog.csdn.net/liangyihuai/article/details/77094996?utm_source=app
https://blog.csdn.net/u012234115/article/details/39717215?utm_source=app
https://blog.csdn.net/Marshalldong/article/details/88062969?utm_source=app
https://www.cnblogs.com/youxin/p/3279391.html
https://blog.csdn.net/fly_chen/article/details/53079173
https://www.cnblogs.com/youxin/archive/2012/03/27/2420023.html
https://blog.csdn.net/luguifang2011/article/details/39988627
https://www.cnblogs.com/xiaofengkang/archive/2011/05/20/2052452.html
https://www.cnblogs.com/hongcha717/archive/2010/10/24/1859780.html
https://www.jianshu.com/p/f54547d24221

#### 一级指针与二级指针

- C语言的函数永远是值传递（除了数组），所以想改变指针的指向（地址值），就必须传递指针的指针（二级指针），除非用return。如果只是修改指针指向的值，使用一级指针就可以，如两数交换；
- *p是p所指向的地址存放的数据，p是p所指向的地址，&p是p的地址；
- 指针变量修改所指向的内容的时候，因为指针指向的是其内存地址，所以，就相当于把该内存中的内容修改了。这一点是指针强大的原因所在，也是它存在的原因；
- 指针星号的作用在定义与使用时不同，在指针定义的时候表明该变量是指针变量以及是几级指针（有几个星号就表示几级），在使用时能够通过指针变量所指向的内存地址（或者说上图中Value的值）来获取对应内存的内容；
- [普通变量和指针变量实质上的区别](https://blog.csdn.net/liangyihuai/article/details/77094996?utm_source=app)是：指针变量的变量值value 存储的是一个用16进制表示的32位内存地址，比如00A6F790。而普通变量的变量值value 所存储的内容没有限制。还有，指针变量能够根据变量值value中的内存地址获取到该地址所对应的值（假设指针变量名为p，通过*p来获取）。具体如图所示；

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170811105620415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbmd5aWh1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 二级指针的Value保存一级指针的地址Addr。如指针变量poiterVar1初始化的时候指向了NULL。可以通过二级指针poiterVar2修改一级指针poiterVar1，使其指向有效的内存空间。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170811110531982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlhbmd5aWh1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

~~~c
void fun(int *node) // 这里的node不是主程序里的node，是一个保存在栈空间的指针变量node
{
	static int N = 100; // N存储在静态存储区
	node = &N; // 把N的地址赋给指针变量node。但是node是栈空间的一个指针变量。函数调用结束后，node就不存在了。所以这条赋值是没有意义的。
}

void fun2(int **node)
{
	static int N = 100; // 可以没有static
	*node = &N; // 二级指针node所指向的一级指针的地址存放的是N的地址；即*p2 = value(p1)
}

int main()
{
	/*空指针 
	int a = 5;
	
//	int *p = NULL;
	int *p = 0; 
	printf("d = %d, s = %s, p = %p\n", p, p, p); // d = 0, s = (null), p = 0000000000000000
	printf("d = %d", *p); // 可以读取NULL本身的值，即0,但是读取它指向的值，那是非法的，会引发段错误
	
//  指针的两种初始化方法
//	int *p = &a; 
	int *p = NULL;
	p = &a;
	
	printf("a = %p, p = %p, size = %d, &p = %p\n", &a, p, sizeof(p), &p); // &a == p
	printf("psize = %d, intsize = %d\n", sizeof(p), sizeof(int)); // psize = 8, intsize = 4
	*/
	
	int *p = NULL; // 空指针 
	int a = 0;
	
//	fun(p); // 指针p的值作为实参，所以传递的是0
	
	fun2(&p); // 二级指针可实现值的传递 
	
	a = *p; // 这里的p是主程序的p,其值还是NULL，对NULL取*操作造成段错误。
	
	printf("%d\n", a);
	
//  指针
	int *q = NULL;
	int b = 5;
	q = &b;
	printf("*q = %d, q = %p, &q = %p\n", *q, q, &q);
	*q = ++b; // 修改指针指向的值，指针不变 
	printf("*q = %d, q = %p, &q = %p\n", *q, q, &q);
	int c = 8;
	q = &c; // 修改指针的指向，指针改变 
	printf("*q = %d, q = %p, &q = %p\n", *q, q, &q);
	
//	*p是p所指向的地址存放的数据，p是p所指向的地址，&p是p的地址
//	*q = 5, q = 000000000062FE34, &q = 000000000062FE38  
//	*q = 6, q = 000000000062FE34, &q = 000000000062FE38
//	*q = 8, q = 000000000062FE30, &q = 000000000062FE38
	
	return 0;
}
~~~

#### 指针类型和指针类型转换



#### [二维数组作为函数的参数](https://www.cnblogs.com/alantu2018/p/8465894.html)



#### 二维数组与二级指针



#### if

- if把0当作flase，其它全为true；

- if中的负数计算结果实际上是相当于强转成了unsigned int。原因是cpu做逻辑计算的时候都是做无符号数拓展，所有数都是当作无符号来看待的；
- NULL

~~~c
	if (-1)
	{
		printf("1");
	}	
	if (0)
	{
		printf("2");
	}
	if (1)
	{
		printf("3");
	}
	if (!(-1)) // !true
	{
		printf("4");
	}
	if (!(0)) // !false
	{
		printf("5");
	}
	if (!(1)) // !true
	{
		printf("6");
	}
	
	// 输出结果为 135 
~~~
### C++

#### 指针与引用

#### 函数三种传递方式

### Python

#### 数据类型

#### 标准输入输出

#### [垃圾回收机制](https://mp.weixin.qq.com/s/Y1-TE9eel4CMr2OlL_AxeA)

在python中的垃圾回收机制（Garbage Collection:GC）主要是**以引用计数为主要手段，以标记清除和隔代回收机制为辅的手段 。**可以对内存中无效数据的自动管理。其中标记清除解决容器对象产生循环引用的问题，隔代回收以空间换时间的方式来提高垃圾回收的效率。

1. 引用计数

- 原理

每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。

- 优点

高效，实时性能优秀，能在最短的时间获得并运算对象引用数，对象有确定的生命周期，操作简单，易于实现 。 

- 缺点

维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。

无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。

2. 标记清除

- 原理

标记-清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法，主要是针对可能产生循环引用的对象进行的检测机制 。它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。

只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。

在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python 解释器 (Cpython) 维护了两个这样的**双端链表**，一个链表存放着需要被扫描的容器对象，称为 Object to Scan，另一个链表存放着临时不可达对象，称为 Unreachable。

![img](https://mmbiz.qpic.cn/mmbiz_png/KkCMRahHfcpKObbOMgsrrZ84Q8icdWWL0oLC1DMPPr9GOWcyY0hyPuQ7OJPjk0tibgrrVgibib1t4iadjV1wwujlICA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上图中 link1,link2,link3 组成一个引用环，此外 link1 还被变量 A 引用，看图中 link1 被几个箭头指着就知道了，其中 refcount 记录当前对象的引用计数，而 gcref 在一开始，gcref 只是 refcount 的副本，所以 gcref 的初始值等于 refcount。

![img](https://mmbiz.qpic.cn/mmbiz_png/KkCMRahHfcpKObbOMgsrrZ84Q8icdWWL0Zbwnz8km4gkER5FNHwMFegrWBBD7MszaicriceBSD0AfdpmOmUFzrbjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

gc 启动的时候，会逐个遍历”Object to Scan” 链表中的容器对象，并且将当前对象所引用的所有对象的 gcref 减一。这一步操作就相当于解除了循环引用对引用计数的影响。如 link4 是自己引用了自己造成了循环引用，此时 link4 的 gcref 为 0。

![img](https://mmbiz.qpic.cn/mmbiz_png/KkCMRahHfcpKObbOMgsrrZ84Q8icdWWL0WL5sHSGcvNQic49YoopSWrhlggJTBjJjM2oOdfibJG4wdWTPbkvLe6ibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

接着，gc 会再次扫描所有的容器对象，如果对象的 gcref 值为 0，且引用该对象的对象其 gcref 也为 0 ，那么这个对象就被标记为 GCTENTATIVELYUNREACHABLE，并且被移至”Unreachable” 链表中。下图中的 link3 和 link4 就是这样一种情况。

![img](https://mmbiz.qpic.cn/mmbiz_png/KkCMRahHfcpKObbOMgsrrZ84Q8icdWWL0CQogkyjLFLdCtVyibEM7ARoibFoXJTy4AcvXFK1cdY4mk1EIia1xpD6Hg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果对象的 gcref 不为 0，那么这个对象就会被标记为 GCREACHABLE。同时当 gc 发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为 GCREACHABLE, 这就是下图中 link2 和 link3 所碰到的情形。除了将所有可达节点标记为 GCREACHABLE 之外，如果该节点当前在”Unreachable” 链表中的话，还需要将其移回到”Object to Scan” 链表中，下图就是 link3 移回之后的情形。

第二次遍历的所有对象都遍历完成之后，存在于”Unreachable” 链表中的对象就是真正需要被释放的对象。如上图所示，此时 link4 存在于 Unreachable 链表中，gc 随即释放之。

- 缺点

引用计数 + 标记 - 清除 的方式实现了 Python 垃圾回收，但整个过程比较慢，而且在 标记 - 清除 过程中还需要暂停整个程序，为了减少应用程序暂停使用，Python 利用分代回收 (Generational Collection) 以空间换时间的方式来提高垃圾回收效率。

3. 隔代回收

- 原理

python gc 给对象定义了三种世代 (0,1,2)（链表）， 每一个新生对象在 generation zero 中，如果它在一轮 gc 扫描中活了下来，那么它将被移至 generation one, 在那里他将较少的被扫描，如果它又活过了一轮 gc， 它又将被移至 generation two，在那里它被扫描的次数将会更少，直到触发对应的阈值。

当某一世代被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发 gc 对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代 2 的 gc 扫描被触发了，那么世代 0、世代 1 也将被扫描，如果世代 1 的 gc 扫描被触发，世代 0 也会被扫描。

gc 模快有一个自动垃圾回收的阀值，即通过 gc.get_threshold 函数获取到的长度为 3 的元组，其默认值为 (700,10,10)。每一次计数器的增加，gc 模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器。

- 实例

假设阀值是 (700,10,10)：

当计数器从 (699,8,0) 增加到 (700,8,0)，gc 模块就会执行 gc.collect (0), 即检查 0 代对象的垃圾，并重置计数器为 (0,9,0)；

当计数器从 (699,9,0) 增加到 (700,9,0)，gc 模块就会执行 gc.collect (1), 即检查 0、1代对象的垃圾，并重置计数器为 (0,0,1)；

当计数器从 (699,9,9) 增加到 (700,9,9)，gc 模块就会执行 gc.collect (2), 即检查 0、1、2 代对象的垃圾，并重置计数器为 (0,0,0)。

#### 值传递和引用传递

python中对一个函数可以传递参数，但是Python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。实际上，**这种方式相当于传值和传引用的一种综合**。python根据传入的数据对象，自动识别是传值还是传引用。

如果传入的参数对象是可变对象：列表，字典，这个时候就是引用传递，如果参数在函数体内被修改，那么源对象也会被修改。

如果传入的参数对象是不可变的对象：数字，元组，字符串，这个时候就是值传递。那么源对象是不会改变的。

**对于不可变对象，赋值与拷贝相同。对于可变对象，赋值与拷贝不同。**

~~~python
# 可变对象与不可变对象分别作为函数参数时的效果
>>> def change(x, y):
...     a[0] = 4
...     b = 5
>>> a = [1, 2]
>>> b = 3
>>> change(a, b)
>>> a
[4, 2]
>>> b
3

# 两者的输出不同
>>> def change2(x):
...     x += [6]			# 未创建新的对象
...     print(id(x))
>>> id(a)
1738915781320
>>> change2(a)
1738915781320
>>> a
[4, 2, 6]
>>> def change2(x):
...     x = x + [7]	 		# 创建新的对象 
...     print(id(x))
>>> id(a)
1738915781320
>>> change2(a)
1738915768136
>>> a
[4, 2, 6]
	
>>> id(a)					
1738913391496
>>> a.pop()					# 在原地址上修改可变对象
8
>>> id(a)
1738913391496
>>> a.append(9)
>>> a
[4, 2, 6, 9]

# 对于可变对象，赋值与拷贝不同。
>>> id(a)
1738913391496
>>> b = a
>>> id(b)
1738913391496
>>> b
[4, 2, 6, 9]
>>> import copy
>>> b = copy.copy(a)
>>> id(b)
1738915673096
>>> b = copy.deepcopy(a)
>>> id(b)
1738912581832

# 对于不可变对象，赋值与拷贝相同。
>>> c = 2
>>> id(c)
140731555558256
>>> d = c
>>> id(d)
140731555558256
>>> d = copy.copy(c)
>>> id(d)
140731555558256
>>> d = copy.deepcopy(c)
>>> id(d)
140731555558256
~~~

#### 协程

#### 迭代器

可迭代对象iterable与迭代器iterator：

- Iterable可迭代对象，继承Iterator，必须要实现iter魔法函数（可以用for循环）。如字符串、列表；

- Iterator迭代器对象，必须要实现next魔法函数。如生成器对象，可以使用iter(list)将列表转化为迭代器。

#### 生成器







#### 装饰器

装饰器使用闭包在没有修改原函数调用方式的前提下，完成原函数功能的扩展。





#### with

<https://blog.csdn.net/tralonzhang/article/details/37775541>

with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如文件使用后自动关闭／线程中锁的自动获取和释放等。

有了上下文管理器，with 语句才能工作。上下文管理器（Context Manager）是支持上下文管理协议的对象，这种对象实现了-enter-() 和 -exit-() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。

通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。

工作原理：

- 紧跟with后面的语句被求值后，返回对象的 “–enter–()” 方法被调用，这个方法的返回值将被赋值给as后面的变量； 
- 当with后面的代码块全部被执行完之后，将调用前面返回对象的“–exit–()” 方法；
- -exit-() 方法中有３个参数， exc_type, exc_val, exc_tb，这些参数在异常处理中相当有用。 分别为：exc_type：错误的类型、exc_val：错误类型对应的值、exc_tb：代码中错误发生的位置。没有异常时返回值均为None；
- 开发库时，清理资源，关闭文件等操作，都可以放在 -exit()- 方法中。 总之，with-as表达式极大的简化了每次写finally的工作。

~~~python
class Sample_1():
    def __enter__(self):
        print("in __enter__")
        return 'Foo'
    
    # TypeError: __exit__() takes 1 positional argument but 4 were given
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("in __exit__")
        print("exc_type", exc_type)
        print("exc_val", exc_val)
        print("exc_tb", exc_tb)

def get_sample_1():
    return Sample_1()

with get_sample_1() as sample:
    print(sample)

# in __enter__
# Foo
# in __exit__
# exc_type None
# exc_val None
# exc_tb None    

# 模拟发生异常
class Sample_2():
    def __enter__(self):
        print("in __enter__")
        return self
    
    # TypeError: __exit__() takes 1 positional argument but 4 were given
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("exc_type", exc_type)
        print("exc_val", exc_val)
        print("exc_tb", exc_tb)

    def do_something(self):
        result = 1 / 0
        return result
    
def get_sample_2():
    return Sample_2()

with get_sample_2() as sample:
    sample.do_something()

# in __enter__
# exc_type <class 'ZeroDivisionError'>
# exc_val division by zero
# exc_tb <traceback object at 0x000001460A0FEF48>
# Traceback (most recent call last):
#   File ".\test.py", line 44, in <module>
#     sample.do_something()
#   File ".\test.py", line 35, in do_something
#     result = 1 / 0
# ZeroDivisionError: division by zero
~~~

#### map、reduce、lambda

- lambda：优点是匿名函数，返回值就是该表达式的结果。缺点是函数传参时不方便。
- map：优点是便于函数传参，参数都是列表，返回也是列表。这样可以实现一次传入多组参数。可以把它想成一个for循环，它不断从列表中取值，将参数合并为元组后交给lambda，然后得到结果后返回列表存储；
- reduce：优点是简化递归，迭代等运算。函数执行的流程为先取第一第二个数作为x，y然后进行计算，计算出来的数赋给x，然后取第三个数赋给y，再用x，y做计算，再算完的数，又当做下一轮的x，再从列表中取一个数当做y，再来，就是不断迭代的过程；
- 列表推导式：有两种构建方式，循环模式 [变量(加工后的变量) for 变量 in iterable] 和 筛选模式: [变量(加工后的变量) for 变量 in iterable if 条件] 增加一个判断；
- filter：filter(function, sequence)，作用是按照所定义的函数过滤掉列表中的一些元素。删选规则复杂一点，需要用函数定义那种复杂，可以用filter，不然还是列表推导式吧，就是对其他程序员可能不太友好如果列表推导式太长的话。

~~~python
print((lambda x,y:x*y+x)(x=22,y=3))
print(map(Whatever,[22,3," ","MrLevo"],[3,22,3,2]))

from functools import reduce
print(reduce(lambda x,y:x*y,[1,2,3,4,5]))

print(reduce(lambda x,y:x*y,[x for x in range(1,6)])) # 简化传参
print([x for x in range(1,6) if x%2 == 1]) # 筛选奇数
print([i**2 for i in range(1, 11)]) # 将10以内所有整数的平方写入列表
print([x for x in ['MrLevo', '', '520', None, ' '] if x and x.strip()]) # 筛选非空白字符
~~~

#### 相关文件

- .idea文件夹

pycharm作为IDE时，会自动生成.idea文件夹用来存放项目的配置信息。这个文件夹是自动生成，版本控制信息等，包括历史记录。

### JAVA

#### JVM

#### JDK

#### JRE

#### JDBC


## 操作系统

### 内存

#### LRU缓存

LRU 就是一种缓存淘汰策略。

计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉那些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为有用的的数据呢？

LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是有用的，很久都没用过的数据应该是无用的，缓存满了就优先删那些很久没用过的数据。

#### 寄存器

#### 文件描述符

#### 管道

#### echo

### CPU

#### CPU平衡

#### CPU调度

#### 并发与并行

#### 同步与异步

#### 进程

![è¿ç¨](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622115300479-2129397443.png)

进程(线程+内存+文件/网络句柄)

- 内存

我们通常所理解的内存是我们所见到的(2G/4G/8G/16G)物理内存，它为什么会在进程之中呢？

实际上，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。否则的话会出现一个问题：我们把指针的值改一改就指向其他进程的内存了。

- 文件/网络句柄

它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。

系统调用fork()创建子进程：

<https://www.cnblogs.com/wannable/p/6021597.html>

![img](https://images2015.cnblogs.com/blog/982686/201611/982686-20161102003740174-1446852149.png)

getpid返回的是当前进程的PID。子进程pid=0，父进程pid>0。这样就为怎么写子进程的程序提供了一个方法来隔离代码。

连续执行两次fork()函数会创建三个三个子进程，共四个进程。

#### 线程

![çº¿ç¨](https://img2018.cnblogs.com/blog/1629488/201906/1629488-20190622115318812-109279192.png)

线程(栈+PC+TLS)

- 栈

我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。那么我们的栈里面有什么呢？

我们从主线程的入口main函数，会不断的进行函数调用，每次调用的时候，会把所有的参数和返回地址压入到栈中，**一个函数调用称为一个栈帧**。数据结构栈后进先出的特性符合函数调用的特性。

- PC

Program Counter 程序计数器，操作系统真正运行的是一个个的线程，而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。

计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的。这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。

- TLS

thread local storage 线性本地存储。之前我们看到每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢？答案是有的，就是TLS。可以用来存储我们线程所独有的数据。

可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。

同一个进程中的线程是共享数据段的，进程是操作系统分配资源的单位，而线程是操作系统真正调度的单位，创建线程时并不会对数据线程进行重新分配。

线程有自己的threadID、栈和寄存器集合的值，这些在线程上下文切换时，操作系统都会做好相应的保存后才能切换，**栈和寄存器的值以及程序计数器的值表明了当前线程的执行过程**，对这些进行保存就能保存好执行的现场，以便下次返回时继续执行。

线程共享的内容包括：

- 进程代码段

- 进程数据段
- 进程打开的文件描述符
- 信号的处理器
- 进程的当前目录
- 进程用户ID与进程组ID
- 堆

线程独有的内容包括：

- 线程ID
- 寄存器组的值
- 线程的栈
- 错误返回码
- 线程的信号屏蔽码

#### 进程与线程

1. 程序、进程、线程

程序是指令、数据及其组织形式的描述。程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体；

进程（Process）是程序的实体，是计算机中的程序关于某数据集合上的一次运行活动。进程是一个动态的实体，它有自己的生命周期。进程的生存期状态包括创建、就绪、运行、阻塞和死亡等类型。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消。**进程反映了一个程序在一定的数据集上运行的全部动态过程**。因此一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块（PCB）来唯一地标识每个进程。从应用程序进程在执行过程中向CPU发出的运行指令形式不同，可以将进程的状态分为用户态和核心态。**处于用户态下的进程执行的是应用程序指令、处于核心态下的应用程序进程执行的是操作系统指令**；

一条线程（thread）指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。**线程是共享了进程的上下文环境的更为细小的CPU时间段**。

简而言之，一个程序至少有一个进程，一个进程至少有一个线程。

2. 进程与线程的区别

- 根本区别：**进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位**。

- 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

- 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。

- 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。进程有自己独立的地址空间，**每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段**，线程没有独立的地址空间，它使用相同的地址空间共享数据。
- 通信方式：线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行（但多线程程序处理好同步与互斥是个难点）。进程间的通讯往往要求内核的参与，以提供通讯机制和保护机制，而线程间的通讯是在同一进程的地址空间内，共享主存和文件，无需内核参与。
- 安全性：多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）。

- 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

#### 进程间通信方式

通信方式包括信号、管道、消息队列、共享内存。



#### 线程间通信方式

#### 锁

#### 原子操作

写实读写

#### 进程管理工具

### 容器与仓库

#### Map-Reduce模型

## 网络

### 通信

#### OSI 七层模型

OSI，是英文Open System Interconnect的缩写，中文翻译开放系统互联。

以TCP/IP为框架模型，国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合提出并制定了这个七层的OSI参考模型：

1）应用层 2）表示层 3）会话层 4）传输层 5）网络层 6）链路层  7）物理层

各层有不同的协议，用户数据经过以上七道工序的流水线，一串0、1组成的二进制流诞生了，根据物理层是光纤、电缆、还是空气，二进制流转化为光信号、电信号、电磁波信号在物理介质（物理层）里传输，经过若干个中继交换机（链路层）的交换、经过若干个中继路由器（网络层）的转发，最终到达数据的终点。

以上七道工序最终产生了二进制流，每道工序都会在原始数据前添加一串属于自己的协议头，每个协议头有源主机的每层工序产生，自然有理解这些协议头的对端。

![img](https://user-gold-cdn.xitu.io/2017/10/20/ac3ea7262b3c4525d784722dc0f46634?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如图所示，发送方从最高层开始，从上到下按顺序传输数据，除了物理层之外，每一层接收到由上层处理的数据时，添加该层的首部并可能会对数据进行处理（如表示层）。明确界定各层的作用，有助于系统的健壮性。其中应用层、表示层和会话层是为用户提供服务的。传输层、网络层、数据链路层和物理层是为传输数据提供服务的。

- 物理层：设备之间比特流的传输，物理接口，电气特性等等。常见的设备有网线，网卡等等。数据单位是比特。物理层负责0、1比特流（0、1序列）与电压高低、光的闪灭之间的互换。典型的协议有 RS 232C、RS 449/422/423、V.24 和 X.21、X.21bis 等。**集线器工作在物理层**；

- 数据链路层：成帧，用Mac地址访问媒介，错误检测与修正。数据单位是帧。该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。常见的协议有 HDLC、PPP、SLIP 等。**MAC地址和交换机都工作在这一层**；

- 网络层：提供逻辑地址（IP地址）、选路（选择传输路线）。数据单位是报文。网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由 IP、ICMP 两个协议组成。**IP地址和路由器就是工作在网络层**；

- 传输层：确定传输的可靠性，进行传输前的错误检测，流控。数据单位是TPDU。数据单位是段(Segment)。传输层有一个重要作用，就是指定通信端口。**每一个应用程序都会在网卡注册一个端口号**。以请求服务器数据为例，服务器有处理多种协议的能力，如之前应用层所说的HTTP，FTP，TELNET 等，如果指定了端口，如 80，服务器就会知道是用 HTTP 协议的，自然会转给对应协议的处理程序进行处理。此层有两个具有代表性的协议： TCP 与 UDP；

- 会话层：对应用会话的管理，同步。确定网络数据是否要经过远程会话 。数据单位是SPDU。会话层区分不同的会话，以及提供单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务。我们平时所知的NFS，RPC，X Windows等都工作在这一层；

- 表示层：数据的表现形式，特定功能的实现，数据单位是PPDU。比如浏览器请求回一堆数据，是解析成文本还是图片，就由表示层决定。数据的压缩、加密、打包等功能也都在这层完成。常见的协议有 ASCII、SSL/TLS 等。一层根据不同的应用目的将数据处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名；

- 应用层：用户接口，无限接近用户。数据单位是APDU。包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。如把把浏览器看作一个应用，当用户发起请求时，通过 HTTP协议获得数据以供浏览器使用，这就是应用层的用途。而请求时发生错误，对错误进行处理，也是应用层需要负责的。

#### 交换机与路由器



#### 路由

#### QoS

#### 安全

#### URL

从URL输入到页面展现到底发生什么？

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。

总体来说分为以下几个过程：

- DNS 域名解析：将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

![img](https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSumplAiaC2NW3oNc1KawG3jXPes8jYjqZ8cXyJHTBmia94ic7uCFWPEEacPAdibIY6EwAxwh92opa7q8Vg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 子网掩码

IP地址是互联网上每个子网或每个主机在网络上的唯一身份标签。子网掩码是一种用来指明一个IP地址所标示的主机处于哪个子网中。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

- 子网掩码AND IP地址的部分是网络标识；

- 子网掩码取反后AND IP地址的部分即为主机标识。

子网掩码有两个特殊地址，当子网掩码的主机地址全为0时，表示该网络地址，当子网掩码的主机地址全为1时，表示该网络的广播地址。

### 协议

#### TCP/IP

#### [TCP](https://blog.csdn.net/qq_38950316/article/details/81087809)

建立起一个TCP连接需要经过“三次握手”。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。**断开连接时服务器和客户端均可以主动发起断开TCP连接的请求**。断开过程需要经过“四次握手”。

- 标志位与序号

ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。

同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建立连接时才会被置1，握手完成后SYN标志位被置0。

终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。

- 三次握手

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

三次握手的作用如：

1、确认双方的接受能力、发送能力是否正常。

2、指定自己的初始化序列号，为后面的可靠传送做准备。

3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。

- 为什么两次握手不可以？

> 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
>
>
> 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。**不过此时服务器并不能确认客户端的接收能力是否正常。**有可能产生死锁。
>
>
> 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。谢希仁著《计算机网络》中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

- ISN

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

- 半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

- 超时重传

这里在补充一点关于SYN-ACK 重传次数的问题：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….。

- 四次挥手

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命 Maximum Segment Lifetime）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，**服务器结束TCP连接的时间要比客户端早一些**。

- TIME_WAIT

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。

所谓的2MSL是两倍的MSL(最大报文段生存时间)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为**当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。**但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

- 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### SOCKET

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

**创建Socket连接时，可以指定使用的传输层协议**，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

#### HTTP与TCP

**HTTP属于应用层，TCP属于传输层。**HTTP是基于TCP连接的。简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。HTTP是用来收发数据，即实际应用上来的。

HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，HTTP协议是建立在TCP协议之上的一种应用。

HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

客户端要和服务端连接TCP连接，需要通过三次连接，包括：请求，确认，建立连接。即传说中的“三次握手协议”。在客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。

总体就是客户端发送一个HTTP请求（包括请求头和请求体）给服务器，服务器收到了这个http请求，然后返回给客户端http响应，然后客户端的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。

#### TCP与UDP

TCP在真正通信之前要三次握手，是面向连接的；并且**TCP利用序列号保证消息的有序性**。而UDP对应的则是可靠性要求低，但是流量大、速度快的应用；和TCP相比，UDP是无连接的并且可能是无序的。

TCP更重量，UDP更轻量，没有高低之分，只是应用的场景不同。

- 面向报文

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

- 面向字节流

面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

- 协议比较

![TCP/UDPæ¯è¾](https://img-blog.csdn.net/20151018103115179)

- 应用场景

![TCP/UDPå¸¸è§åºç¨](https://img-blog.csdn.net/20151018100130736)

- 编程模型

![TCP/UDPç¼ç¨æ¨¡å](https://img-blog.csdn.net/20151018103233366)

#### HTTP

- 请求

TCP 三次握手结束后，开始发送 HTTP 请求报文。

![img](https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSumplAiaC2NW3oNc1KawG3jXPLh9XAZ0eqoNxricI7AFQOtzJAlsBUZyOBWwVthu1DzBknPhhwFKBHGg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 响应

服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。每台服务器上都会安装**处理请求的应用——web server**。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。

web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。

后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）-- 视图（view）--控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。

![img](https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSumplAiaC2NW3oNc1KawG3jXPumFHCcBJQ7TnqCbTwh9UOcjI7micUk8IVZCyGXJgH9EiaJWnJ96E9fyg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

执行的流程为：首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。

响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：

![img](https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSumplAiaC2NW3oNc1KawG3jXPlKjiby3ZVkTyy30BicAIR6qCKxDScey71BrjvxlH5sLr3wgp1Xsrx5Lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### HTTP状态码

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190617205341135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2MzAwMA==,size_16,color_FFFFFF,t_70)

常见状态码：

- 200 OK:客户端请求成功
- 301 Moved Permanently ：永久重定向，永久重定向请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。
- 302  Found (Temporary Redirect)：临时重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。重定向的url还有可能还会改变。
- 304 not modified：客户端发送附带条件的请求时（if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。**304虽然被划分在3xx类别中，但是和重定向没有关系。**
- 400 Bad Request: 客户端请求语法错误、服务器无法解析。比如url含有非法字符
- 401 Unauthorized：请求未经授权
- 403 Forbidden：服务器收到请求拒绝服务
- 404 Not Found：请求资源不存在，常见URL错误
- 405 method not allowed：请求的方式（get、post、delete）方法与后台规定的方式不符合。比如： 后台方法规定的请求方式只接受get，如果用post请求，就会出现 405 method not allowed的提示
- 500 Internal Server Error：服务端内部错误
- 503 Server Unavailable：服务器当前不能处理客户端请求

#### HTTP与HTTPS

#### GET与POST

请求方式之GET和POST的区别：

最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

本质上都是TCP连接，不同之处在于GET产生一个TCP数据包，POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。

#### cookie与session

**cookie存储在本地浏览器，而session存储在服务器。**

- cookie

在网站中，**http请求是无状态的**。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

为了解决客户端与服务端会话同步问题，**把服务器中产生的会话sessionID存储到客户端浏览器cookie中去。**在客户端存在周期为浏览器关闭时，消失。这样便解决了客户端请求服务端会话不同步问题。

cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。通常，cookie用于判断两个请求是否来自同一个浏览器。例如，保持用户登录。它记住无状态 HTTP协议的有状态信息。

**cookie由服务器生成，发送给浏览器**，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

- session

session 从字面上讲，就是会话。服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

- cookie和session结合使用

web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1、存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。

- tomcat中cookie与session

在tomcat中session id中用JSESSIONID来表示。**session id 相同即认为是同一个会话**。服务器只会在客户端第一次请求响应的时候，在响应头上添加Set-Cookie：“JSESSIONID=XXXXXXX”信息，接下来在同一个会话的第二第三次响应头里，是不会添加Set- Cookie：“JSESSIONID=XXXXXXX”信息的； 而客户端是会在每次请求头的cookie中带上JSESSIONID信息。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180705090758830?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4Mjk2OTI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### DNS

#### ARP



## 数学

### 概率论

#### 贝叶斯公式